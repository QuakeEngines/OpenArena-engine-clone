diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./android/android_glimp.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/android_glimp.c
--- ./android/android_glimp.c	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/android_glimp.c	2012-05-25 14:17:10.337231585 +0300
@@ -0,0 +1,312 @@
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/param.h>
+
+#include "android_glimp.h"
+#include "../client/client.h"
+#include "../renderer/tr_local.h"
+
+static int screen_width=0;
+static int screen_height=0;
+
+static qboolean GLimp_HaveExtension(const char *ext)
+{
+	const char *ptr = Q_stristr( glConfig.extensions_string, ext );
+	if (ptr == NULL)
+		return qfalse;
+	ptr += strlen(ext);
+	return ((*ptr == ' ') || (*ptr == '\0'));  // verify it's complete string.
+}
+
+static void qglMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
+{
+	qglMultiTexCoord4f(target,s,t,1,1);
+}
+
+/*
+===============
+GLimp_InitExtensions
+===============
+*/
+static void GLimp_InitExtensions( void )
+{
+	if ( !r_allowExtensions->integer )
+	{
+		ri.Printf( PRINT_ALL, "* IGNORING OPENGL EXTENSIONS *\n" );
+		return;
+	}
+
+	ri.Printf( PRINT_ALL, "Initializing OpenGL extensions\n" );
+
+	glConfig.textureCompression = TC_NONE;
+
+	// GL_EXT_texture_compression_s3tc
+	if ( GLimp_HaveExtension( "GL_ARB_texture_compression" ) &&
+	     GLimp_HaveExtension( "GL_EXT_texture_compression_s3tc" ) )
+	{
+		if ( r_ext_compressed_textures->value )
+		{
+			glConfig.textureCompression = TC_S3TC_ARB;
+			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_compression_s3tc\n" );
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_compression_s3tc\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_texture_compression_s3tc not found\n" );
+	}
+
+	// GL_S3_s3tc ... legacy extension before GL_EXT_texture_compression_s3tc.
+	if (glConfig.textureCompression == TC_NONE)
+	{
+		if ( GLimp_HaveExtension( "GL_S3_s3tc" ) )
+		{
+			if ( r_ext_compressed_textures->value )
+			{
+				glConfig.textureCompression = TC_S3TC;
+				ri.Printf( PRINT_ALL, "...using GL_S3_s3tc\n" );
+			}
+			else
+			{
+				ri.Printf( PRINT_ALL, "...ignoring GL_S3_s3tc\n" );
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...GL_S3_s3tc not found\n" );
+		}
+	}
+
+
+	// GL_EXT_texture_env_add
+	glConfig.textureEnvAddAvailable = qtrue; //qfalse;
+#if 0
+	if ( GLimp_HaveExtension( "EXT_texture_env_add" ) )
+	{
+		if ( r_ext_texture_env_add->integer )
+		{
+			glConfig.textureEnvAddAvailable = qtrue;
+			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_env_add\n" );
+		}
+		else
+		{
+			glConfig.textureEnvAddAvailable = qfalse;
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_env_add\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_texture_env_add not found\n" );
+	}
+#endif
+
+	// GL_ARB_multitexture
+	/*
+	qglMultiTexCoord2fARB = NULL;
+	qglActiveTextureARB = NULL;
+	qglClientActiveTextureARB = NULL;
+	*/
+	//if ( GLimp_HaveExtension( "GL_ARB_multitexture" ) )
+	{
+		if ( r_ext_multitexture->value )
+		{
+			qglMultiTexCoord2fARB = qglMultiTexCoord2f;
+			qglActiveTextureARB = qglActiveTexture;
+			qglClientActiveTextureARB = qglClientActiveTexture;
+
+			if ( qglActiveTextureARB )
+			{
+				GLint glint = 0;
+				qglGetIntegerv( GL_MAX_TEXTURE_UNITS, &glint );
+				glConfig.numTextureUnits = (int) glint;
+				if ( glConfig.numTextureUnits > 1 )
+				{
+					ri.Printf( PRINT_ALL, "...using GL_ARB_multitexture\n" );
+				}
+				else
+				{
+					qglMultiTexCoord2fARB = NULL;
+					qglActiveTextureARB = NULL;
+					qglClientActiveTextureARB = NULL;
+					ri.Printf( PRINT_ALL, "...not using GL_ARB_multitexture, < 2 texture units\n" );
+				}
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_ARB_multitexture\n" );
+		}
+	}
+#if 0
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_ARB_multitexture not found\n" );
+	}
+#endif
+
+#if 0
+	// GL_EXT_compiled_vertex_array
+	if ( GLimp_HaveExtension( "GL_EXT_compiled_vertex_array" ) )
+	{
+		if ( r_ext_compiled_vertex_array->value )
+		{
+			ri.Printf( PRINT_ALL, "...using GL_EXT_compiled_vertex_array\n" );
+			qglLockArraysEXT = ( void ( APIENTRY * )( GLint, GLint ) ) SDL_GL_GetProcAddress( "glLockArraysEXT" );
+			qglUnlockArraysEXT = ( void ( APIENTRY * )( void ) ) SDL_GL_GetProcAddress( "glUnlockArraysEXT" );
+			if (!qglLockArraysEXT || !qglUnlockArraysEXT)
+			{
+				ri.Error (ERR_FATAL, "bad getprocaddress");
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_compiled_vertex_array\n" );
+		}
+	}
+	else
+#endif
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_compiled_vertex_array not found\n" );
+	}
+
+	textureFilterAnisotropic = qfalse;
+#if 0
+	if ( GLimp_HaveExtension( "GL_EXT_texture_filter_anisotropic" ) )
+	{
+		if ( r_ext_texture_filter_anisotropic->integer ) {
+			qglGetIntegerv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, (GLint *)&maxAnisotropy );
+			if ( maxAnisotropy <= 0 ) {
+				ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not properly supported!\n" );
+				maxAnisotropy = 0;
+			}
+			else
+			{
+				ri.Printf( PRINT_ALL, "...using GL_EXT_texture_filter_anisotropic (max: %i)\n", maxAnisotropy );
+				textureFilterAnisotropic = qtrue;
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_filter_anisotropic\n" );
+		}
+	}
+	else
+#endif
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not found\n" );
+	}
+}
+
+void GLimp_Init(void)
+{
+	ri.Printf(PRINT_ALL, "Initializing OpenGL subsystem\n");
+
+	bzero(&glConfig, sizeof(glConfig));
+
+	glConfig.isFullscreen = r_fullscreen->integer;
+	glConfig.vidWidth = screen_width;
+	glConfig.vidHeight = screen_height;
+	glConfig.windowAspect = (float)glConfig.vidWidth / glConfig.vidHeight;
+	// FIXME
+	glConfig.colorBits = 16;
+	glConfig.stencilBits = 8;
+	glConfig.depthBits = 24;
+	glConfig.textureCompression = TC_NONE;
+
+	// This values force the UI to disable driver selection
+	glConfig.driverType = GLDRV_ICD;
+	glConfig.hardwareType = GLHW_GENERIC;
+
+	Q_strncpyz(glConfig.vendor_string,
+		   (const char *)qglGetString(GL_VENDOR),
+		   sizeof(glConfig.vendor_string));
+	Q_strncpyz(glConfig.renderer_string,
+		   (const char *)qglGetString(GL_RENDERER),
+		   sizeof(glConfig.renderer_string));
+	Q_strncpyz(glConfig.version_string,
+		   (const char *)qglGetString(GL_VERSION),
+		   sizeof(glConfig.version_string));
+	Q_strncpyz(glConfig.extensions_string,
+		   (const char *)qglGetString(GL_EXTENSIONS),
+		   sizeof(glConfig.extensions_string));
+
+	qglLockArraysEXT = qglLockArrays;
+	qglUnlockArraysEXT = qglUnlockArrays;
+
+	GLimp_InitExtensions();
+
+	IN_Init( );
+
+	ri.Printf(PRINT_ALL, "------------------\n");
+}
+
+void GLimp_LogComment(char *comment)
+{
+	//fprintf(stderr, "%s: %s\n", __func__, comment);
+//	ri.Printf(PRINT_ALL, "%s: %s\n", __func__, comment);
+}
+
+void GLimp_EndFrame(void)
+{
+}
+
+void GLimp_Shutdown(void)
+{
+}
+
+void qglArrayElement(GLint i)
+{
+}
+
+void qglCallList(GLuint list)
+{
+}
+
+void qglDrawBuffer(GLenum mode)
+{
+}
+
+void qglLockArrays(GLint i, GLsizei size)
+{
+}
+
+void qglUnlockArrays(void)
+{
+}
+
+void GLimp_SetGamma(unsigned char red[256], unsigned char green[256],
+		    unsigned char blue[256])
+{
+}
+
+qboolean GLimp_SpawnRenderThread(void (*function) (void))
+{
+	return qfalse;
+}
+
+void GLimp_FrontEndSleep(void)
+{
+}
+
+void *GLimp_RendererSleep(void)
+{
+	return NULL;
+}
+
+void GLimp_RenderThreadWrapper(void *data)
+{
+}
+
+void GLimp_WakeRenderer(void *data)
+{
+}
+
+void setResolution(int width, int height)
+{
+	screen_width = width;
+	screen_height = height;
+}
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./android/android_glimp.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/android_glimp.h
--- ./android/android_glimp.h	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/android_glimp.h	2012-05-25 14:17:10.337231585 +0300
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2009  Nokia Corporation.  All rights reserved.
+ */
+
+#ifndef __ANDROID_GLIMP_H__
+#define __ANDROID_GLIMP_H__
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/param.h>
+
+#include <GLES/gl.h>
+
+#include "android_input.h"
+
+#ifndef GLAPI
+#define GLAPI extern
+#endif
+
+#ifndef GLAPIENTRY
+#define GLAPIENTRY
+#endif
+
+#ifndef APIENTRY
+#define APIENTRY GLAPIENTRY
+#endif
+
+/* "P" suffix to be used for a pointer to a function */
+#ifndef APIENTRYP
+#define APIENTRYP APIENTRY *
+#endif
+
+#ifndef GLAPIENTRYP
+#define GLAPIENTRYP GLAPIENTRY *
+#endif
+
+void GLimp_Init(void);
+void GLimp_LogComment(char *comment);
+void GLimp_EndFrame(void);
+void GLimp_Shutdown(void);
+void qglArrayElement(GLint i);
+void qglCallList(GLuint list);
+void qglDrawBuffer(GLenum mode);
+void qglLockArrays(GLint i, GLsizei size);
+void qglUnlockArrays(void);
+void GLimp_SetGamma(unsigned char red[256], unsigned char green[256],
+		    unsigned char blue[256]);
+qboolean GLimp_SpawnRenderThread(void (*function) (void));
+void GLimp_FrontEndSleep(void);
+void *GLimp_RendererSleep(void);
+void GLimp_RenderThreadWrapper(void *data);
+void GLimp_WakeRenderer(void *data);
+
+#endif
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./android/android_input.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/android_input.c
--- ./android/android_input.c	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/android_input.c	2012-05-25 14:17:10.337231585 +0300
@@ -0,0 +1,273 @@
+/*
+ * Android input code for Quake3
+ * Copyright (C) 2010 Roderick Colenbrander
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "android_glimp.h"
+#include "../client/client.h"
+#include "../renderer/tr_local.h"
+#include "../qcommon/q_shared.h"
+
+/* These variables are for confining menu input to 640x480 */
+static float scale_ratio;
+static int offset_x;
+
+/* Shared cursor position between touch and trackball code */
+static float cursor_x=0, cursor_y=0;
+
+static qboolean motion_event = qfalse;
+static float motion_dx=0;
+static float motion_dy=0;
+
+static qboolean trackball_event = qfalse;
+static float trackball_dx = 0;
+static float trackball_dy = 0;
+
+void (*setMenuState)(int shown);
+
+void setInputCallbacks(void *set_menu_state)
+{
+    setMenuState = set_menu_state;
+}
+
+void queueKeyEvent(int key, int state)
+{
+    int t = Sys_Milliseconds();
+    char character = key;
+
+    /* The game distinguishes between key code and character for some keys (not sure which all).
+     * Perform such a fixup for backspace. If there are more important keys then we might have to do
+     * it somewhere else.
+     */
+    if(key == K_BACKSPACE)
+        character = '\b';
+
+    Com_QueueEvent(t, SE_KEY, key, state, 0, NULL);
+    Com_DPrintf("SE_KEY key=%d state=%d\n", key, state);
+
+    /* For ASCII characters we need both a SE_CHAR, so that we can type and a SE_KEY */
+    if(state == 1 && (key >= ' ' && key <= 127))
+    {
+        Com_DPrintf("SE_CHAR key=%d state=%d\n", character, state);
+        Com_QueueEvent(t, SE_CHAR, character, 0, 0, NULL);
+    }
+}
+
+enum Action
+{
+    ACTION_DOWN=0,
+    ACTION_UP=1,
+    ACTION_MOVE=2
+};
+
+
+void queueMotionEvent(int action, float x, float y, float pressure)
+{
+    static float motion_initial_x=0, motion_initial_y=0;
+    int t = Sys_Milliseconds();
+
+    static float motion_x_down;
+    static float motion_y_down;
+
+    /* The actual motion code is in processMotionEvents. Here we track the movement. On touch down
+     * we record the initial coordinates and during movement we store the last coordinate. When the
+     * game requests new movement data we provide it with the difference between the initial and final
+     * coordinates.
+     */
+
+    switch(action)
+    {
+        case ACTION_DOWN:
+            /* When the position change between ACTION_DOWN and ACTION_UP is small we generate a mouse click.
+             * Pressure can be used as well but the values differ a lot between devices, so calibration
+             * or a list of thresholds would be needed. The position change works reliably.
+             */
+            motion_x_down = x;
+            motion_y_down = y;
+            break;
+
+        case ACTION_UP:
+            if((fabsf(motion_x_down - x) < 3) && (fabsf(motion_y_down - y) < 3))
+            {
+                Com_QueueEvent(t, SE_KEY, K_MOUSE1, 1, 0, NULL);
+                Com_QueueEvent(t, SE_KEY, K_MOUSE1, 0, 0, NULL);
+            }
+            break;
+
+        case ACTION_MOVE:
+            motion_event = qtrue;
+            motion_dx += x-motion_initial_x;
+            motion_dy += y-motion_initial_y;
+            break;
+    }
+
+    motion_initial_x = x;
+    motion_initial_y = y;
+    cursor_x = x;
+    cursor_y = y;
+}
+
+/* The quake3 menu is 640x480, make sure the coordinates originating from this area are scaled.
+ * The UI code already contains clamping to 640x480, so don't perform it here.
+ */
+inline int scale_x_input(float x)
+{
+    return (int)((x - offset_x)*scale_ratio);
+}
+
+inline int scale_y_input(float y)
+{
+    return (int)(y*scale_ratio);
+}
+
+static void processMotionEvents(void)
+{
+    if(motion_event)
+    {
+        int t = Sys_Milliseconds(); //what time should we use?
+
+        /* For some reason we have to use absolute coordinates in the main menu (CA_DISCONNECTED).
+         * The N900 version performs some coordinate translation in cl_input.c
+         * when in game but not in other places. I'm not sure why it did that
+         * and why he doesn't have to distringuish between relative and absolute while
+         * I have.
+         */
+        if(cls.state == CA_DISCONNECTED)
+            Com_QueueEvent(t, SE_MOUSE, scale_x_input(cursor_x), scale_y_input(cursor_y), 0, NULL);
+        else
+            Com_QueueEvent(t, SE_MOUSE, (int)(motion_dx), (int)(motion_dy), 0, NULL);
+
+        motion_event = qfalse;
+        motion_dx = 0;
+        motion_dy = 0;
+    }
+}
+
+void queueTrackballEvent(int action, float dx, float dy)
+{
+    int t = Sys_Milliseconds(); //what time should we use?
+    static int keyPress=0;
+
+    switch(action)
+    {
+        case ACTION_DOWN:
+            Com_QueueEvent(t, SE_KEY, K_MOUSE1, 1, 0, NULL);
+            keyPress=1;
+            break;
+        case ACTION_UP:
+            if(keyPress)
+                Com_QueueEvent(t, SE_KEY, K_MOUSE1, 0, 0, NULL);
+            keyPress=0;
+    }
+
+    /* We accumulate all displacements until we draw a new frame. */
+    trackball_dx += dx;
+    trackball_dy += dy;
+    trackball_event = qtrue;
+}
+
+inline float clamp_to_screen_width(float x)
+{
+    if(x > SCREEN_WIDTH)
+        return SCREEN_WIDTH;
+    else if(x < 0)
+        return 0;
+    return x;
+}
+
+inline float clamp_to_screen_height(float y)
+{
+    if(y > SCREEN_HEIGHT)
+        return SCREEN_HEIGHT;
+    else if(y < 0)
+        return 0;
+    return y;
+}
+
+static void processTrackballEvents(void)
+{
+    if(trackball_event)
+    {
+        int t = Sys_Milliseconds(); //what time should we use?
+
+        /* Trackball dx/dy are <1.0, so make them a bit bigger to prevent kilometers of scrolling */
+        trackball_dx *= 50.0;
+        trackball_dy *= 50.0;
+        cursor_x += trackball_dx;
+        cursor_y += trackball_dy;
+
+        cursor_x = clamp_to_screen_width(cursor_x);
+        cursor_y = clamp_to_screen_height(cursor_y);
+
+        if(cls.state == CA_DISCONNECTED)
+            Com_QueueEvent(t, SE_MOUSE, (int)cursor_x, (int)cursor_y, 0, NULL);
+        else
+            Com_QueueEvent(t, SE_MOUSE, (int)trackball_dx, (int)trackball_dy, 0, NULL);
+
+        trackball_event = qfalse;
+        trackball_dx = 0;
+        trackball_dy = 0;
+    }
+}
+
+void IN_Frame(void)
+{
+    static int prev_state = -1;
+    int state = -1;
+    processMotionEvents();
+    processTrackballEvents();
+
+    /* We are in game and neither console/ui is active */
+    if (cls.state == CA_ACTIVE && Key_GetCatcher() == 0)
+        state = 1;
+    else
+        state = 0;
+
+    if (state != prev_state)
+    {
+        setMenuState(state);
+        prev_state = state;
+    }
+}
+
+void IN_Init(void)
+{
+    scale_ratio = (float)SCREEN_HEIGHT/glConfig.vidHeight;
+    offset_x = (glConfig.vidWidth - ((float)SCREEN_WIDTH/scale_ratio))/2;
+}
+
+qboolean IN_MotionPressed(void)
+{
+    return qfalse;
+}
+
+void IN_Shutdown(void)
+{
+}
+
+void IN_Restart(void)
+{
+    IN_Init();
+}
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./android/android_input.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/android_input.h
--- ./android/android_input.h	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/android_input.h	2012-05-25 14:17:10.337231585 +0300
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2009  Nokia Corporation.  All rights reserved.
+ */
+
+#ifndef __ANDROID_INPUT_H__
+#define __ANDROID_INPUT_H__
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/param.h>
+
+#include "../qcommon/q_shared.h"
+
+extern cvar_t *in_nograb;
+qboolean IN_MotionPressed(void);
+void IN_Frame(void);
+void IN_Init(void);
+void IN_Shutdown(void);
+void IN_Restart(void);
+
+#endif
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./android/android_snd.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/android_snd.c
--- ./android/android_snd.c	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/android_snd.c	2012-05-25 14:17:10.337231585 +0300
@@ -0,0 +1,85 @@
+/*
+ * Android audio code for Quake3
+ * Copyright (C) 2010 Roderick Colenbrander
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "../client/snd_local.h"
+
+static int buf_size=0;
+static int bytes_per_sample=0;
+static int chunkSizeBytes=0;
+static int dmapos=0;
+
+int  (*getPos)(void);
+void (*initAudio)(void *buffer, int size);
+void (*writeAudio)(int offset, int length);
+
+void setAudioCallbacks(void *get_pos, void *write_audio, void *init_audio)
+{
+    getPos = get_pos;
+    writeAudio = write_audio;
+    initAudio = init_audio;
+}
+
+qboolean SNDDMA_Init(void)
+{
+    Com_Printf("Initializing Android Sound subsystem\n");
+
+    /* For now hardcode this all :) */
+    dma.channels = 2;
+    dma.samples = 32768;
+    dma.samplebits = 16;
+
+    dma.submission_chunk = 4096; /* This is in single samples, so this would equal 2048 frames (assuming stereo) in Android terminology */
+    dma.speed = 44100; /* This is the native sample frequency of the Milestone */
+
+    bytes_per_sample = dma.samplebits/8;
+    buf_size = dma.samples * bytes_per_sample;
+    dma.buffer = calloc(1, buf_size);
+
+    chunkSizeBytes = dma.submission_chunk * bytes_per_sample;
+
+    initAudio(dma.buffer, buf_size);
+
+    return qtrue;
+}
+
+
+int SNDDMA_GetDMAPos(void)
+{
+    return dmapos;
+}
+
+void SNDDMA_Shutdown(void)
+{
+    Com_Printf("SNDDMA_ShutDown\n");
+}
+
+void SNDDMA_BeginPainting (void)
+{
+}
+
+void requestAudioData(void)
+{
+    int offset = (dmapos * bytes_per_sample) & (buf_size - 1);
+    writeAudio(offset, chunkSizeBytes);
+    dmapos+=dma.submission_chunk;
+}
+
+void SNDDMA_Submit(void)
+{
+}
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./android/GenerateQGL.pl /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/GenerateQGL.pl
--- ./android/GenerateQGL.pl	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/GenerateQGL.pl	2012-05-25 14:17:10.337231585 +0300
@@ -0,0 +1,147 @@
+#!/usr/bin/perl
+
+open(INPUT_FILE, ">/tmp/input-$$.h") || die "$!";
+print INPUT_FILE "#import <GLES/gl.h>\n";
+close INPUT_FILE;
+open(CPP, "/usr/bin/cpp /tmp/input-$$.h|") || die "$!";
+
+print "/**** This file is autogenerated.  Run GenerateQGL.pl to update it ****/\n\n";
+
+print "#ifdef QGL_LOG_GL_CALLS\n";
+print "extern unsigned int QGLLogGLCalls;\n";
+print "extern FILE *QGLDebugFile(void);\n";
+print "#endif\n\n";
+
+print "extern void QGLCheckError(const char *message);\n";
+print "extern unsigned int QGLBeginStarted;\n\n";
+print "// This has to be done to avoid infinite recursion between our glGetError wrapper and QGLCheckError()\n";
+print "static inline GLenum _glGetError(void) {\n";
+print "    return glGetError();\n";
+print "}\n\n";
+
+@functionNames = ();
+
+while (<CPP>) {
+    chop;
+    /^extern/ || next;
+    s/extern //;
+    print "// $_\n";
+
+    # This approach is necessary to deal with glGetString whos type isn't a single word
+    ($type, $rest) = m/(.+)\s+(gl.*)/;
+#    print "type='$type'\n";
+#    print "rest='$rest'\n";
+
+    ($name, $argString) = ($rest =~ m/(\w+).*\s*\((.*)\)/);
+	next if ($name eq "glColor4f");
+    $isVoid = ($type =~ m/void/);
+    push(@functionNames, $name);
+
+#    print "name=$name\n";
+#    print "argString=$argString\n";
+#    print "argCount=$#args\n";
+
+    # Parse the argument list into two arrays, one of types and one of argument names
+    if ($argString =~ m/^void$/) {
+        @args = ();
+    } else {
+        @args = split(",", $argString);
+    }
+    @argTypes = ();
+    @argNames = ();
+    for $arg (@args) {
+        ($argType, $argName) = ($arg =~ m/(.*[ \*])([_a-zA-Z0-9]+)/);
+        $argType =~ s/^ *//;
+        $argType =~ s/ *$//;
+
+        push(@argTypes, $argType);
+        push(@argNames, $argName);
+#        print "argType='$argType'\n";
+#        print "argName='$argName'\n";
+    }
+
+
+    print "static inline $type q$name($argString)\n";
+    print "{\n";
+
+    if (! $isVoid) {
+        print "    $type returnValue;\n";
+    }
+
+    print "#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)\n";
+    print "    if (QGLLogGLCalls)\n";
+    print "        fprintf(QGLDebugFile(), \"$name(";
+
+    if ($#argTypes >= 0) {
+        for ($i = 0; $i <= $#argTypes; $i++) {
+            $argType = $argTypes[$i];
+            $argName = $argNames[$i];
+            $_ = $argType;
+            if (/^GLenum$/ || /^GLuint$/ || /^GLbitfield$/) {
+                print "$argName=%lu";
+            } elsif (/^GLsizei$/ || /^GLint$/ || /^GLsizeiptr$/ || /^GLintptr$/ || /^GLfixed$/ || /^GLclampx$/) {
+                print "$argName=%ld";
+            } elsif (/^GLfloat$/ || /^GLdouble$/ || /^GLclampf$/ || /^GLclampd$/) {
+                print "$argName=%f";
+            } elsif (/^GLbyte$/) {
+                print "$argName=%d";
+            } elsif (/^GLubyte$/) {
+                print "$argName=%u";
+            } elsif (/^GLshort$/) {
+                print "$argName=%d";
+            } elsif (/^GLushort$/) {
+                print "$argName=%u";
+            } elsif (/^GLboolean$/) {
+                print "$argName=%u";
+            } elsif (/\*$/) {
+                # TJW -- Later we should look at the count specified in the function name, look at the basic type and print out an array.  Or we could just special case them...
+                print "$argName=%p";
+            } else {
+                print STDERR "Unknown type '$argType'\n";
+                exit(1);
+            }
+
+            print ", " if ($i != $#argTypes);
+        }
+    } else {
+        print "void";
+    }
+
+    print ")\\n\"";
+    print ", " if $#argTypes >= 0;
+    print join(", ", @argNames);
+    print ");\n";
+    print "#endif\n";
+
+    if (! $isVoid) {
+        print "    returnValue = ";
+    } else {
+        print "    ";
+    }
+    print "$name(" . join(", ", @argNames) . ");\n";
+
+    print "#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)\n";
+    if ($name eq "glBegin") {
+        print "    QGLBeginStarted++;\n";
+    }
+    if ($name eq "glEnd") {
+        print "    QGLBeginStarted--;\n";
+    }
+    print "    if (!QGLBeginStarted)\n";
+    print "        QGLCheckError(\"$name\");\n";
+    print "#endif\n";
+
+    if (! $isVoid) {
+        print "    return returnValue;\n";
+    }
+    
+    print "}\n\n";
+}
+
+
+print "// Prevent calls to the 'normal' GL functions\n";
+for $name (@functionNames) {
+    print "#define $name CALL_THE_QGL_VERSION_OF_$name\n";
+}
+
+
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./android/qgl.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/qgl.h
--- ./android/qgl.h	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/android/qgl.h	2012-05-25 14:17:10.337231585 +0300
@@ -0,0 +1,2187 @@
+/**** This file is autogenerated.  Run GenerateQGL.pl to update it ****/
+
+#ifdef QGL_LOG_GL_CALLS
+extern unsigned int QGLLogGLCalls;
+extern FILE *QGLDebugFile(void);
+#endif
+
+extern void QGLCheckError(const char *message);
+extern unsigned int QGLBeginStarted;
+
+// This has to be done to avoid infinite recursion between our glGetError wrapper and QGLCheckError()
+static inline GLenum _glGetError(void) {
+    return glGetError();
+}
+
+// void glAlphaFunc (GLenum func, GLclampf ref);
+static inline void qglAlphaFunc(GLenum func, GLclampf ref)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glAlphaFunc(func=%lu, ref=%f)\n", func, ref);
+#endif
+    glAlphaFunc(func, ref);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glAlphaFunc");
+#endif
+}
+
+// void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+static inline void qglClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClearColor(red=%f, green=%f, blue=%f, alpha=%f)\n", red, green, blue, alpha);
+#endif
+    glClearColor(red, green, blue, alpha);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClearColor");
+#endif
+}
+
+// void glClearDepthf (GLclampf depth);
+static inline void qglClearDepthf(GLclampf depth)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClearDepthf(depth=%f)\n", depth);
+#endif
+    glClearDepthf(depth);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClearDepthf");
+#endif
+}
+
+// void glClipPlanef (GLenum plane, const GLfloat *equation);
+static inline void qglClipPlanef(GLenum plane, const GLfloat *equation)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClipPlanef(plane=%lu, equation=%p)\n", plane, equation);
+#endif
+    glClipPlanef(plane, equation);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClipPlanef");
+#endif
+}
+
+// void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
+// void glDepthRangef (GLclampf zNear, GLclampf zFar);
+static inline void qglDepthRangef(GLclampf zNear, GLclampf zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDepthRangef(zNear=%f, zFar=%f)\n", zNear, zFar);
+#endif
+    glDepthRangef(zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDepthRangef");
+#endif
+}
+
+// void glFogf (GLenum pname, GLfloat param);
+static inline void qglFogf(GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFogf(pname=%lu, param=%f)\n", pname, param);
+#endif
+    glFogf(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFogf");
+#endif
+}
+
+// void glFogfv (GLenum pname, const GLfloat *params);
+static inline void qglFogfv(GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFogfv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glFogfv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFogfv");
+#endif
+}
+
+// void glFrustumf (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+static inline void qglFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFrustumf(left=%f, right=%f, bottom=%f, top=%f, zNear=%f, zFar=%f)\n", left, right, bottom, top, zNear, zFar);
+#endif
+    glFrustumf(left, right, bottom, top, zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFrustumf");
+#endif
+}
+
+// void glGetClipPlanef (GLenum pname, GLfloat eqn[4]);
+static inline void qglGetClipPlanef(GLenum pname, GLfloat eqn[4])
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetClipPlanef(pname=%lu, eqn=%f)\n", pname, eqn);
+#endif
+    glGetClipPlanef(pname, eqn);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetClipPlanef");
+#endif
+}
+
+// void glGetFloatv (GLenum pname, GLfloat *params);
+static inline void qglGetFloatv(GLenum pname, GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetFloatv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glGetFloatv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetFloatv");
+#endif
+}
+
+// void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
+static inline void qglGetLightfv(GLenum light, GLenum pname, GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetLightfv(light=%lu, pname=%lu, params=%p)\n", light, pname, params);
+#endif
+    glGetLightfv(light, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetLightfv");
+#endif
+}
+
+// void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
+static inline void qglGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetMaterialfv(face=%lu, pname=%lu, params=%p)\n", face, pname, params);
+#endif
+    glGetMaterialfv(face, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetMaterialfv");
+#endif
+}
+
+// void glGetTexEnvfv (GLenum env, GLenum pname, GLfloat *params);
+static inline void qglGetTexEnvfv(GLenum env, GLenum pname, GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexEnvfv(env=%lu, pname=%lu, params=%p)\n", env, pname, params);
+#endif
+    glGetTexEnvfv(env, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexEnvfv");
+#endif
+}
+
+// void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
+static inline void qglGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexParameterfv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glGetTexParameterfv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexParameterfv");
+#endif
+}
+
+// void glLightModelf (GLenum pname, GLfloat param);
+static inline void qglLightModelf(GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightModelf(pname=%lu, param=%f)\n", pname, param);
+#endif
+    glLightModelf(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightModelf");
+#endif
+}
+
+// void glLightModelfv (GLenum pname, const GLfloat *params);
+static inline void qglLightModelfv(GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightModelfv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glLightModelfv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightModelfv");
+#endif
+}
+
+// void glLightf (GLenum light, GLenum pname, GLfloat param);
+static inline void qglLightf(GLenum light, GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightf(light=%lu, pname=%lu, param=%f)\n", light, pname, param);
+#endif
+    glLightf(light, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightf");
+#endif
+}
+
+// void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
+static inline void qglLightfv(GLenum light, GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightfv(light=%lu, pname=%lu, params=%p)\n", light, pname, params);
+#endif
+    glLightfv(light, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightfv");
+#endif
+}
+
+// void glLineWidth (GLfloat width);
+static inline void qglLineWidth(GLfloat width)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLineWidth(width=%f)\n", width);
+#endif
+    glLineWidth(width);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLineWidth");
+#endif
+}
+
+// void glLoadMatrixf (const GLfloat *m);
+static inline void qglLoadMatrixf(const GLfloat *m)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLoadMatrixf(m=%p)\n", m);
+#endif
+    glLoadMatrixf(m);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLoadMatrixf");
+#endif
+}
+
+// void glMaterialf (GLenum face, GLenum pname, GLfloat param);
+static inline void qglMaterialf(GLenum face, GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMaterialf(face=%lu, pname=%lu, param=%f)\n", face, pname, param);
+#endif
+    glMaterialf(face, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMaterialf");
+#endif
+}
+
+// void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
+static inline void qglMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMaterialfv(face=%lu, pname=%lu, params=%p)\n", face, pname, params);
+#endif
+    glMaterialfv(face, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMaterialfv");
+#endif
+}
+
+// void glMultMatrixf (const GLfloat *m);
+static inline void qglMultMatrixf(const GLfloat *m)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMultMatrixf(m=%p)\n", m);
+#endif
+    glMultMatrixf(m);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMultMatrixf");
+#endif
+}
+
+// void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+static inline void qglMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMultiTexCoord4f(target=%lu, s=%f, t=%f, r=%f, q=%f)\n", target, s, t, r, q);
+#endif
+    glMultiTexCoord4f(target, s, t, r, q);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMultiTexCoord4f");
+#endif
+}
+
+// void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
+static inline void qglNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glNormal3f(nx=%f, ny=%f, nz=%f)\n", nx, ny, nz);
+#endif
+    glNormal3f(nx, ny, nz);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glNormal3f");
+#endif
+}
+
+// void glOrthof (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+static inline void qglOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glOrthof(left=%f, right=%f, bottom=%f, top=%f, zNear=%f, zFar=%f)\n", left, right, bottom, top, zNear, zFar);
+#endif
+    glOrthof(left, right, bottom, top, zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glOrthof");
+#endif
+}
+
+// void glPointParameterf (GLenum pname, GLfloat param);
+static inline void qglPointParameterf(GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointParameterf(pname=%lu, param=%f)\n", pname, param);
+#endif
+    glPointParameterf(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointParameterf");
+#endif
+}
+
+// void glPointParameterfv (GLenum pname, const GLfloat *params);
+static inline void qglPointParameterfv(GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointParameterfv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glPointParameterfv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointParameterfv");
+#endif
+}
+
+// void glPointSize (GLfloat size);
+static inline void qglPointSize(GLfloat size)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointSize(size=%f)\n", size);
+#endif
+    glPointSize(size);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointSize");
+#endif
+}
+
+// void glPolygonOffset (GLfloat factor, GLfloat units);
+static inline void qglPolygonOffset(GLfloat factor, GLfloat units)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPolygonOffset(factor=%f, units=%f)\n", factor, units);
+#endif
+    glPolygonOffset(factor, units);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPolygonOffset");
+#endif
+}
+
+// void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
+static inline void qglRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glRotatef(angle=%f, x=%f, y=%f, z=%f)\n", angle, x, y, z);
+#endif
+    glRotatef(angle, x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glRotatef");
+#endif
+}
+
+// void glScalef (GLfloat x, GLfloat y, GLfloat z);
+static inline void qglScalef(GLfloat x, GLfloat y, GLfloat z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glScalef(x=%f, y=%f, z=%f)\n", x, y, z);
+#endif
+    glScalef(x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glScalef");
+#endif
+}
+
+// void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
+static inline void qglTexEnvf(GLenum target, GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnvf(target=%lu, pname=%lu, param=%f)\n", target, pname, param);
+#endif
+    glTexEnvf(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnvf");
+#endif
+}
+
+// void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
+static inline void qglTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnvfv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexEnvfv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnvfv");
+#endif
+}
+
+// void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
+static inline void qglTexParameterf(GLenum target, GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameterf(target=%lu, pname=%lu, param=%f)\n", target, pname, param);
+#endif
+    glTexParameterf(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameterf");
+#endif
+}
+
+// void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
+static inline void qglTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameterfv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexParameterfv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameterfv");
+#endif
+}
+
+// void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
+static inline void qglTranslatef(GLfloat x, GLfloat y, GLfloat z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTranslatef(x=%f, y=%f, z=%f)\n", x, y, z);
+#endif
+    glTranslatef(x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTranslatef");
+#endif
+}
+
+// void glActiveTexture (GLenum texture);
+static inline void qglActiveTexture(GLenum texture)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glActiveTexture(texture=%lu)\n", texture);
+#endif
+    glActiveTexture(texture);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glActiveTexture");
+#endif
+}
+
+// void glAlphaFuncx (GLenum func, GLclampx ref);
+static inline void qglAlphaFuncx(GLenum func, GLclampx ref)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glAlphaFuncx(func=%lu, ref=%ld)\n", func, ref);
+#endif
+    glAlphaFuncx(func, ref);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glAlphaFuncx");
+#endif
+}
+
+// void glBindBuffer (GLenum target, GLuint buffer);
+static inline void qglBindBuffer(GLenum target, GLuint buffer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glBindBuffer(target=%lu, buffer=%lu)\n", target, buffer);
+#endif
+    glBindBuffer(target, buffer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glBindBuffer");
+#endif
+}
+
+// void glBindTexture (GLenum target, GLuint texture);
+static inline void qglBindTexture(GLenum target, GLuint texture)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glBindTexture(target=%lu, texture=%lu)\n", target, texture);
+#endif
+    glBindTexture(target, texture);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glBindTexture");
+#endif
+}
+
+// void glBlendFunc (GLenum sfactor, GLenum dfactor);
+static inline void qglBlendFunc(GLenum sfactor, GLenum dfactor)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glBlendFunc(sfactor=%lu, dfactor=%lu)\n", sfactor, dfactor);
+#endif
+    glBlendFunc(sfactor, dfactor);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glBlendFunc");
+#endif
+}
+
+// void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
+static inline void qglBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glBufferData(target=%lu, size=%ld, data=%p, usage=%lu)\n", target, size, data, usage);
+#endif
+    glBufferData(target, size, data, usage);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glBufferData");
+#endif
+}
+
+// void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
+static inline void qglBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glBufferSubData(target=%lu, offset=%ld, size=%ld, data=%p)\n", target, offset, size, data);
+#endif
+    glBufferSubData(target, offset, size, data);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glBufferSubData");
+#endif
+}
+
+// void glClear (GLbitfield mask);
+static inline void qglClear(GLbitfield mask)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClear(mask=%lu)\n", mask);
+#endif
+    glClear(mask);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClear");
+#endif
+}
+
+// void glClearColorx (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
+static inline void qglClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClearColorx(red=%ld, green=%ld, blue=%ld, alpha=%ld)\n", red, green, blue, alpha);
+#endif
+    glClearColorx(red, green, blue, alpha);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClearColorx");
+#endif
+}
+
+// void glClearDepthx (GLclampx depth);
+static inline void qglClearDepthx(GLclampx depth)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClearDepthx(depth=%ld)\n", depth);
+#endif
+    glClearDepthx(depth);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClearDepthx");
+#endif
+}
+
+// void glClearStencil (GLint s);
+static inline void qglClearStencil(GLint s)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClearStencil(s=%ld)\n", s);
+#endif
+    glClearStencil(s);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClearStencil");
+#endif
+}
+
+// void glClientActiveTexture (GLenum texture);
+static inline void qglClientActiveTexture(GLenum texture)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClientActiveTexture(texture=%lu)\n", texture);
+#endif
+    glClientActiveTexture(texture);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClientActiveTexture");
+#endif
+}
+
+// void glClipPlanex (GLenum plane, const GLfixed *equation);
+static inline void qglClipPlanex(GLenum plane, const GLfixed *equation)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClipPlanex(plane=%lu, equation=%p)\n", plane, equation);
+#endif
+    glClipPlanex(plane, equation);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClipPlanex");
+#endif
+}
+
+// void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
+static inline void qglColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glColor4ub(red=%u, green=%u, blue=%u, alpha=%u)\n", red, green, blue, alpha);
+#endif
+    glColor4ub(red, green, blue, alpha);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glColor4ub");
+#endif
+}
+
+// void glColor4x (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
+static inline void qglColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glColor4x(red=%ld, green=%ld, blue=%ld, alpha=%ld)\n", red, green, blue, alpha);
+#endif
+    glColor4x(red, green, blue, alpha);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glColor4x");
+#endif
+}
+
+// void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+static inline void qglColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glColorMask(red=%u, green=%u, blue=%u, alpha=%u)\n", red, green, blue, alpha);
+#endif
+    glColorMask(red, green, blue, alpha);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glColorMask");
+#endif
+}
+
+// void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+static inline void qglColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glColorPointer(size=%ld, type=%lu, stride=%ld, pointer=%p)\n", size, type, stride, pointer);
+#endif
+    glColorPointer(size, type, stride, pointer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glColorPointer");
+#endif
+}
+
+// void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
+static inline void qglCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glCompressedTexImage2D(target=%lu, level=%ld, internalformat=%lu, width=%ld, height=%ld, border=%ld, imageSize=%ld, data=%p)\n", target, level, internalformat, width, height, border, imageSize, data);
+#endif
+    glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glCompressedTexImage2D");
+#endif
+}
+
+// void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
+static inline void qglCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glCompressedTexSubImage2D(target=%lu, level=%ld, xoffset=%ld, yoffset=%ld, width=%ld, height=%ld, format=%lu, imageSize=%ld, data=%p)\n", target, level, xoffset, yoffset, width, height, format, imageSize, data);
+#endif
+    glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glCompressedTexSubImage2D");
+#endif
+}
+
+// void glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+static inline void qglCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glCopyTexImage2D(target=%lu, level=%ld, internalformat=%lu, x=%ld, y=%ld, width=%ld, height=%ld, border=%ld)\n", target, level, internalformat, x, y, width, height, border);
+#endif
+    glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glCopyTexImage2D");
+#endif
+}
+
+// void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+static inline void qglCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glCopyTexSubImage2D(target=%lu, level=%ld, xoffset=%ld, yoffset=%ld, x=%ld, y=%ld, width=%ld, height=%ld)\n", target, level, xoffset, yoffset, x, y, width, height);
+#endif
+    glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glCopyTexSubImage2D");
+#endif
+}
+
+// void glCullFace (GLenum mode);
+static inline void qglCullFace(GLenum mode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glCullFace(mode=%lu)\n", mode);
+#endif
+    glCullFace(mode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glCullFace");
+#endif
+}
+
+// void glDeleteBuffers (GLsizei n, const GLuint *buffers);
+static inline void qglDeleteBuffers(GLsizei n, const GLuint *buffers)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDeleteBuffers(n=%ld, buffers=%p)\n", n, buffers);
+#endif
+    glDeleteBuffers(n, buffers);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDeleteBuffers");
+#endif
+}
+
+// void glDeleteTextures (GLsizei n, const GLuint *textures);
+static inline void qglDeleteTextures(GLsizei n, const GLuint *textures)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDeleteTextures(n=%ld, textures=%p)\n", n, textures);
+#endif
+    glDeleteTextures(n, textures);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDeleteTextures");
+#endif
+}
+
+// void glDepthFunc (GLenum func);
+static inline void qglDepthFunc(GLenum func)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDepthFunc(func=%lu)\n", func);
+#endif
+    glDepthFunc(func);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDepthFunc");
+#endif
+}
+
+// void glDepthMask (GLboolean flag);
+static inline void qglDepthMask(GLboolean flag)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDepthMask(flag=%u)\n", flag);
+#endif
+    glDepthMask(flag);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDepthMask");
+#endif
+}
+
+// void glDepthRangex (GLclampx zNear, GLclampx zFar);
+static inline void qglDepthRangex(GLclampx zNear, GLclampx zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDepthRangex(zNear=%ld, zFar=%ld)\n", zNear, zFar);
+#endif
+    glDepthRangex(zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDepthRangex");
+#endif
+}
+
+// void glDisable (GLenum cap);
+static inline void qglDisable(GLenum cap)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDisable(cap=%lu)\n", cap);
+#endif
+    glDisable(cap);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDisable");
+#endif
+}
+
+// void glDisableClientState (GLenum array);
+static inline void qglDisableClientState(GLenum array)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDisableClientState(array=%lu)\n", array);
+#endif
+    glDisableClientState(array);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDisableClientState");
+#endif
+}
+
+// void glDrawArrays (GLenum mode, GLint first, GLsizei count);
+static inline void qglDrawArrays(GLenum mode, GLint first, GLsizei count)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDrawArrays(mode=%lu, first=%ld, count=%ld)\n", mode, first, count);
+#endif
+    glDrawArrays(mode, first, count);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDrawArrays");
+#endif
+}
+
+// void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
+static inline void qglDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDrawElements(mode=%lu, count=%ld, type=%lu, indices=%p)\n", mode, count, type, indices);
+#endif
+    glDrawElements(mode, count, type, indices);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDrawElements");
+#endif
+}
+
+// void glEnable (GLenum cap);
+static inline void qglEnable(GLenum cap)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glEnable(cap=%lu)\n", cap);
+#endif
+    glEnable(cap);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glEnable");
+#endif
+}
+
+// void glEnableClientState (GLenum array);
+static inline void qglEnableClientState(GLenum array)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glEnableClientState(array=%lu)\n", array);
+#endif
+    glEnableClientState(array);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glEnableClientState");
+#endif
+}
+
+// void glFinish (void);
+static inline void qglFinish(void)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFinish(void)\n");
+#endif
+    glFinish();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFinish");
+#endif
+}
+
+// void glFlush (void);
+static inline void qglFlush(void)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFlush(void)\n");
+#endif
+    glFlush();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFlush");
+#endif
+}
+
+// void glFogx (GLenum pname, GLfixed param);
+static inline void qglFogx(GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFogx(pname=%lu, param=%ld)\n", pname, param);
+#endif
+    glFogx(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFogx");
+#endif
+}
+
+// void glFogxv (GLenum pname, const GLfixed *params);
+static inline void qglFogxv(GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFogxv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glFogxv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFogxv");
+#endif
+}
+
+// void glFrontFace (GLenum mode);
+static inline void qglFrontFace(GLenum mode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFrontFace(mode=%lu)\n", mode);
+#endif
+    glFrontFace(mode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFrontFace");
+#endif
+}
+
+// void glFrustumx (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
+static inline void qglFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFrustumx(left=%ld, right=%ld, bottom=%ld, top=%ld, zNear=%ld, zFar=%ld)\n", left, right, bottom, top, zNear, zFar);
+#endif
+    glFrustumx(left, right, bottom, top, zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFrustumx");
+#endif
+}
+
+// void glGetBooleanv (GLenum pname, GLboolean *params);
+static inline void qglGetBooleanv(GLenum pname, GLboolean *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetBooleanv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glGetBooleanv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetBooleanv");
+#endif
+}
+
+// void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
+static inline void qglGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetBufferParameteriv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glGetBufferParameteriv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetBufferParameteriv");
+#endif
+}
+
+// void glGetClipPlanex (GLenum pname, GLfixed eqn[4]);
+static inline void qglGetClipPlanex(GLenum pname, GLfixed eqn[4])
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetClipPlanex(pname=%lu, eqn=%ld)\n", pname, eqn);
+#endif
+    glGetClipPlanex(pname, eqn);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetClipPlanex");
+#endif
+}
+
+// void glGenBuffers (GLsizei n, GLuint *buffers);
+static inline void qglGenBuffers(GLsizei n, GLuint *buffers)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGenBuffers(n=%ld, buffers=%p)\n", n, buffers);
+#endif
+    glGenBuffers(n, buffers);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGenBuffers");
+#endif
+}
+
+// void glGenTextures (GLsizei n, GLuint *textures);
+static inline void qglGenTextures(GLsizei n, GLuint *textures)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGenTextures(n=%ld, textures=%p)\n", n, textures);
+#endif
+    glGenTextures(n, textures);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGenTextures");
+#endif
+}
+
+// GLenum glGetError (void);
+static inline GLenum qglGetError(void)
+{
+    GLenum returnValue;
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetError(void)\n");
+#endif
+    returnValue = glGetError();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetError");
+#endif
+    return returnValue;
+}
+
+// void glGetFixedv (GLenum pname, GLfixed *params);
+static inline void qglGetFixedv(GLenum pname, GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetFixedv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glGetFixedv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetFixedv");
+#endif
+}
+
+// void glGetIntegerv (GLenum pname, GLint *params);
+static inline void qglGetIntegerv(GLenum pname, GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetIntegerv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glGetIntegerv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetIntegerv");
+#endif
+}
+
+// void glGetLightxv (GLenum light, GLenum pname, GLfixed *params);
+static inline void qglGetLightxv(GLenum light, GLenum pname, GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetLightxv(light=%lu, pname=%lu, params=%p)\n", light, pname, params);
+#endif
+    glGetLightxv(light, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetLightxv");
+#endif
+}
+
+// void glGetMaterialxv (GLenum face, GLenum pname, GLfixed *params);
+static inline void qglGetMaterialxv(GLenum face, GLenum pname, GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetMaterialxv(face=%lu, pname=%lu, params=%p)\n", face, pname, params);
+#endif
+    glGetMaterialxv(face, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetMaterialxv");
+#endif
+}
+
+// void glGetPointerv (GLenum pname, void **params);
+static inline void qglGetPointerv(GLenum pname, void **params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetPointerv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glGetPointerv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetPointerv");
+#endif
+}
+
+// const GLubyte * glGetString (GLenum name);
+static inline const GLubyte * qglGetString(GLenum name)
+{
+    const GLubyte * returnValue;
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetString(name=%lu)\n", name);
+#endif
+    returnValue = glGetString(name);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetString");
+#endif
+    return returnValue;
+}
+
+// void glGetTexEnviv (GLenum env, GLenum pname, GLint *params);
+static inline void qglGetTexEnviv(GLenum env, GLenum pname, GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexEnviv(env=%lu, pname=%lu, params=%p)\n", env, pname, params);
+#endif
+    glGetTexEnviv(env, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexEnviv");
+#endif
+}
+
+// void glGetTexEnvxv (GLenum env, GLenum pname, GLfixed *params);
+static inline void qglGetTexEnvxv(GLenum env, GLenum pname, GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexEnvxv(env=%lu, pname=%lu, params=%p)\n", env, pname, params);
+#endif
+    glGetTexEnvxv(env, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexEnvxv");
+#endif
+}
+
+// void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
+static inline void qglGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexParameteriv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glGetTexParameteriv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexParameteriv");
+#endif
+}
+
+// void glGetTexParameterxv (GLenum target, GLenum pname, GLfixed *params);
+static inline void qglGetTexParameterxv(GLenum target, GLenum pname, GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexParameterxv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glGetTexParameterxv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexParameterxv");
+#endif
+}
+
+// void glHint (GLenum target, GLenum mode);
+static inline void qglHint(GLenum target, GLenum mode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glHint(target=%lu, mode=%lu)\n", target, mode);
+#endif
+    glHint(target, mode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glHint");
+#endif
+}
+
+// GLboolean glIsBuffer (GLuint buffer);
+static inline GLboolean qglIsBuffer(GLuint buffer)
+{
+    GLboolean returnValue;
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glIsBuffer(buffer=%lu)\n", buffer);
+#endif
+    returnValue = glIsBuffer(buffer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glIsBuffer");
+#endif
+    return returnValue;
+}
+
+// GLboolean glIsEnabled (GLenum cap);
+static inline GLboolean qglIsEnabled(GLenum cap)
+{
+    GLboolean returnValue;
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glIsEnabled(cap=%lu)\n", cap);
+#endif
+    returnValue = glIsEnabled(cap);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glIsEnabled");
+#endif
+    return returnValue;
+}
+
+// GLboolean glIsTexture (GLuint texture);
+static inline GLboolean qglIsTexture(GLuint texture)
+{
+    GLboolean returnValue;
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glIsTexture(texture=%lu)\n", texture);
+#endif
+    returnValue = glIsTexture(texture);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glIsTexture");
+#endif
+    return returnValue;
+}
+
+// void glLightModelx (GLenum pname, GLfixed param);
+static inline void qglLightModelx(GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightModelx(pname=%lu, param=%ld)\n", pname, param);
+#endif
+    glLightModelx(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightModelx");
+#endif
+}
+
+// void glLightModelxv (GLenum pname, const GLfixed *params);
+static inline void qglLightModelxv(GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightModelxv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glLightModelxv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightModelxv");
+#endif
+}
+
+// void glLightx (GLenum light, GLenum pname, GLfixed param);
+static inline void qglLightx(GLenum light, GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightx(light=%lu, pname=%lu, param=%ld)\n", light, pname, param);
+#endif
+    glLightx(light, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightx");
+#endif
+}
+
+// void glLightxv (GLenum light, GLenum pname, const GLfixed *params);
+static inline void qglLightxv(GLenum light, GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightxv(light=%lu, pname=%lu, params=%p)\n", light, pname, params);
+#endif
+    glLightxv(light, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightxv");
+#endif
+}
+
+// void glLineWidthx (GLfixed width);
+static inline void qglLineWidthx(GLfixed width)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLineWidthx(width=%ld)\n", width);
+#endif
+    glLineWidthx(width);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLineWidthx");
+#endif
+}
+
+// void glLoadIdentity (void);
+static inline void qglLoadIdentity(void)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLoadIdentity(void)\n");
+#endif
+    glLoadIdentity();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLoadIdentity");
+#endif
+}
+
+// void glLoadMatrixx (const GLfixed *m);
+static inline void qglLoadMatrixx(const GLfixed *m)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLoadMatrixx(m=%p)\n", m);
+#endif
+    glLoadMatrixx(m);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLoadMatrixx");
+#endif
+}
+
+// void glLogicOp (GLenum opcode);
+static inline void qglLogicOp(GLenum opcode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLogicOp(opcode=%lu)\n", opcode);
+#endif
+    glLogicOp(opcode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLogicOp");
+#endif
+}
+
+// void glMaterialx (GLenum face, GLenum pname, GLfixed param);
+static inline void qglMaterialx(GLenum face, GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMaterialx(face=%lu, pname=%lu, param=%ld)\n", face, pname, param);
+#endif
+    glMaterialx(face, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMaterialx");
+#endif
+}
+
+// void glMaterialxv (GLenum face, GLenum pname, const GLfixed *params);
+static inline void qglMaterialxv(GLenum face, GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMaterialxv(face=%lu, pname=%lu, params=%p)\n", face, pname, params);
+#endif
+    glMaterialxv(face, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMaterialxv");
+#endif
+}
+
+// void glMatrixMode (GLenum mode);
+static inline void qglMatrixMode(GLenum mode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMatrixMode(mode=%lu)\n", mode);
+#endif
+    glMatrixMode(mode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMatrixMode");
+#endif
+}
+
+// void glMultMatrixx (const GLfixed *m);
+static inline void qglMultMatrixx(const GLfixed *m)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMultMatrixx(m=%p)\n", m);
+#endif
+    glMultMatrixx(m);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMultMatrixx");
+#endif
+}
+
+// void glMultiTexCoord4x (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
+static inline void qglMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMultiTexCoord4x(target=%lu, s=%ld, t=%ld, r=%ld, q=%ld)\n", target, s, t, r, q);
+#endif
+    glMultiTexCoord4x(target, s, t, r, q);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMultiTexCoord4x");
+#endif
+}
+
+// void glNormal3x (GLfixed nx, GLfixed ny, GLfixed nz);
+static inline void qglNormal3x(GLfixed nx, GLfixed ny, GLfixed nz)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glNormal3x(nx=%ld, ny=%ld, nz=%ld)\n", nx, ny, nz);
+#endif
+    glNormal3x(nx, ny, nz);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glNormal3x");
+#endif
+}
+
+// void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
+static inline void qglNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glNormalPointer(type=%lu, stride=%ld, pointer=%p)\n", type, stride, pointer);
+#endif
+    glNormalPointer(type, stride, pointer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glNormalPointer");
+#endif
+}
+
+// void glOrthox (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
+static inline void qglOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glOrthox(left=%ld, right=%ld, bottom=%ld, top=%ld, zNear=%ld, zFar=%ld)\n", left, right, bottom, top, zNear, zFar);
+#endif
+    glOrthox(left, right, bottom, top, zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glOrthox");
+#endif
+}
+
+// void glPixelStorei (GLenum pname, GLint param);
+static inline void qglPixelStorei(GLenum pname, GLint param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPixelStorei(pname=%lu, param=%ld)\n", pname, param);
+#endif
+    glPixelStorei(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPixelStorei");
+#endif
+}
+
+// void glPointParameterx (GLenum pname, GLfixed param);
+static inline void qglPointParameterx(GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointParameterx(pname=%lu, param=%ld)\n", pname, param);
+#endif
+    glPointParameterx(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointParameterx");
+#endif
+}
+
+// void glPointParameterxv (GLenum pname, const GLfixed *params);
+static inline void qglPointParameterxv(GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointParameterxv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glPointParameterxv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointParameterxv");
+#endif
+}
+
+// void glPointSizex (GLfixed size);
+static inline void qglPointSizex(GLfixed size)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointSizex(size=%ld)\n", size);
+#endif
+    glPointSizex(size);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointSizex");
+#endif
+}
+
+// void glPolygonOffsetx (GLfixed factor, GLfixed units);
+static inline void qglPolygonOffsetx(GLfixed factor, GLfixed units)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPolygonOffsetx(factor=%ld, units=%ld)\n", factor, units);
+#endif
+    glPolygonOffsetx(factor, units);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPolygonOffsetx");
+#endif
+}
+
+// void glPopMatrix (void);
+static inline void qglPopMatrix(void)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPopMatrix(void)\n");
+#endif
+    glPopMatrix();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPopMatrix");
+#endif
+}
+
+// void glPushMatrix (void);
+static inline void qglPushMatrix(void)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPushMatrix(void)\n");
+#endif
+    glPushMatrix();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPushMatrix");
+#endif
+}
+
+// void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
+static inline void qglReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glReadPixels(x=%ld, y=%ld, width=%ld, height=%ld, format=%lu, type=%lu, pixels=%p)\n", x, y, width, height, format, type, pixels);
+#endif
+    glReadPixels(x, y, width, height, format, type, pixels);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glReadPixels");
+#endif
+}
+
+// void glRotatex (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
+static inline void qglRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glRotatex(angle=%ld, x=%ld, y=%ld, z=%ld)\n", angle, x, y, z);
+#endif
+    glRotatex(angle, x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glRotatex");
+#endif
+}
+
+// void glSampleCoverage (GLclampf value, GLboolean invert);
+static inline void qglSampleCoverage(GLclampf value, GLboolean invert)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glSampleCoverage(value=%f, invert=%u)\n", value, invert);
+#endif
+    glSampleCoverage(value, invert);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glSampleCoverage");
+#endif
+}
+
+// void glSampleCoveragex (GLclampx value, GLboolean invert);
+static inline void qglSampleCoveragex(GLclampx value, GLboolean invert)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glSampleCoveragex(value=%ld, invert=%u)\n", value, invert);
+#endif
+    glSampleCoveragex(value, invert);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glSampleCoveragex");
+#endif
+}
+
+// void glScalex (GLfixed x, GLfixed y, GLfixed z);
+static inline void qglScalex(GLfixed x, GLfixed y, GLfixed z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glScalex(x=%ld, y=%ld, z=%ld)\n", x, y, z);
+#endif
+    glScalex(x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glScalex");
+#endif
+}
+
+// void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
+static inline void qglScissor(GLint x, GLint y, GLsizei width, GLsizei height)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glScissor(x=%ld, y=%ld, width=%ld, height=%ld)\n", x, y, width, height);
+#endif
+    glScissor(x, y, width, height);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glScissor");
+#endif
+}
+
+// void glShadeModel (GLenum mode);
+static inline void qglShadeModel(GLenum mode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glShadeModel(mode=%lu)\n", mode);
+#endif
+    glShadeModel(mode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glShadeModel");
+#endif
+}
+
+// void glStencilFunc (GLenum func, GLint ref, GLuint mask);
+static inline void qglStencilFunc(GLenum func, GLint ref, GLuint mask)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glStencilFunc(func=%lu, ref=%ld, mask=%lu)\n", func, ref, mask);
+#endif
+    glStencilFunc(func, ref, mask);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glStencilFunc");
+#endif
+}
+
+// void glStencilMask (GLuint mask);
+static inline void qglStencilMask(GLuint mask)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glStencilMask(mask=%lu)\n", mask);
+#endif
+    glStencilMask(mask);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glStencilMask");
+#endif
+}
+
+// void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
+static inline void qglStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glStencilOp(fail=%lu, zfail=%lu, zpass=%lu)\n", fail, zfail, zpass);
+#endif
+    glStencilOp(fail, zfail, zpass);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glStencilOp");
+#endif
+}
+
+// void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+static inline void qglTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexCoordPointer(size=%ld, type=%lu, stride=%ld, pointer=%p)\n", size, type, stride, pointer);
+#endif
+    glTexCoordPointer(size, type, stride, pointer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexCoordPointer");
+#endif
+}
+
+// void glTexEnvi (GLenum target, GLenum pname, GLint param);
+static inline void qglTexEnvi(GLenum target, GLenum pname, GLint param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnvi(target=%lu, pname=%lu, param=%ld)\n", target, pname, param);
+#endif
+    glTexEnvi(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnvi");
+#endif
+}
+
+// void glTexEnvx (GLenum target, GLenum pname, GLfixed param);
+static inline void qglTexEnvx(GLenum target, GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnvx(target=%lu, pname=%lu, param=%ld)\n", target, pname, param);
+#endif
+    glTexEnvx(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnvx");
+#endif
+}
+
+// void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
+static inline void qglTexEnviv(GLenum target, GLenum pname, const GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnviv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexEnviv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnviv");
+#endif
+}
+
+// void glTexEnvxv (GLenum target, GLenum pname, const GLfixed *params);
+static inline void qglTexEnvxv(GLenum target, GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnvxv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexEnvxv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnvxv");
+#endif
+}
+
+// void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+static inline void qglTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexImage2D(target=%lu, level=%ld, internalformat=%ld, width=%ld, height=%ld, border=%ld, format=%lu, type=%lu, pixels=%p)\n", target, level, internalformat, width, height, border, format, type, pixels);
+#endif
+    glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexImage2D");
+#endif
+}
+
+// void glTexParameteri (GLenum target, GLenum pname, GLint param);
+static inline void qglTexParameteri(GLenum target, GLenum pname, GLint param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameteri(target=%lu, pname=%lu, param=%ld)\n", target, pname, param);
+#endif
+    glTexParameteri(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameteri");
+#endif
+}
+
+// void glTexParameterx (GLenum target, GLenum pname, GLfixed param);
+static inline void qglTexParameterx(GLenum target, GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameterx(target=%lu, pname=%lu, param=%ld)\n", target, pname, param);
+#endif
+    glTexParameterx(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameterx");
+#endif
+}
+
+// void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
+static inline void qglTexParameteriv(GLenum target, GLenum pname, const GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameteriv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexParameteriv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameteriv");
+#endif
+}
+
+// void glTexParameterxv (GLenum target, GLenum pname, const GLfixed *params);
+static inline void qglTexParameterxv(GLenum target, GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameterxv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexParameterxv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameterxv");
+#endif
+}
+
+// void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+static inline void qglTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexSubImage2D(target=%lu, level=%ld, xoffset=%ld, yoffset=%ld, width=%ld, height=%ld, format=%lu, type=%lu, pixels=%p)\n", target, level, xoffset, yoffset, width, height, format, type, pixels);
+#endif
+    glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexSubImage2D");
+#endif
+}
+
+// void glTranslatex (GLfixed x, GLfixed y, GLfixed z);
+static inline void qglTranslatex(GLfixed x, GLfixed y, GLfixed z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTranslatex(x=%ld, y=%ld, z=%ld)\n", x, y, z);
+#endif
+    glTranslatex(x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTranslatex");
+#endif
+}
+
+// void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+static inline void qglVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glVertexPointer(size=%ld, type=%lu, stride=%ld, pointer=%p)\n", size, type, stride, pointer);
+#endif
+    glVertexPointer(size, type, stride, pointer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glVertexPointer");
+#endif
+}
+
+// void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
+static inline void qglViewport(GLint x, GLint y, GLsizei width, GLsizei height)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glViewport(x=%ld, y=%ld, width=%ld, height=%ld)\n", x, y, width, height);
+#endif
+    glViewport(x, y, width, height);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glViewport");
+#endif
+}
+
+// void glPointSizePointerOES (GLenum type, GLsizei stride, const GLvoid *pointer);
+static inline void qglPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid *pointer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointSizePointerOES(type=%lu, stride=%ld, pointer=%p)\n", type, stride, pointer);
+#endif
+    glPointSizePointerOES(type, stride, pointer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointSizePointerOES");
+#endif
+}
+
+// Prevent calls to the 'normal' GL functions
+#define glAlphaFunc CALL_THE_QGL_VERSION_OF_glAlphaFunc
+#define glClearColor CALL_THE_QGL_VERSION_OF_glClearColor
+#define glClearDepthf CALL_THE_QGL_VERSION_OF_glClearDepthf
+#define glClipPlanef CALL_THE_QGL_VERSION_OF_glClipPlanef
+#define glDepthRangef CALL_THE_QGL_VERSION_OF_glDepthRangef
+#define glFogf CALL_THE_QGL_VERSION_OF_glFogf
+#define glFogfv CALL_THE_QGL_VERSION_OF_glFogfv
+#define glFrustumf CALL_THE_QGL_VERSION_OF_glFrustumf
+#define glGetClipPlanef CALL_THE_QGL_VERSION_OF_glGetClipPlanef
+#define glGetFloatv CALL_THE_QGL_VERSION_OF_glGetFloatv
+#define glGetLightfv CALL_THE_QGL_VERSION_OF_glGetLightfv
+#define glGetMaterialfv CALL_THE_QGL_VERSION_OF_glGetMaterialfv
+#define glGetTexEnvfv CALL_THE_QGL_VERSION_OF_glGetTexEnvfv
+#define glGetTexParameterfv CALL_THE_QGL_VERSION_OF_glGetTexParameterfv
+#define glLightModelf CALL_THE_QGL_VERSION_OF_glLightModelf
+#define glLightModelfv CALL_THE_QGL_VERSION_OF_glLightModelfv
+#define glLightf CALL_THE_QGL_VERSION_OF_glLightf
+#define glLightfv CALL_THE_QGL_VERSION_OF_glLightfv
+#define glLineWidth CALL_THE_QGL_VERSION_OF_glLineWidth
+#define glLoadMatrixf CALL_THE_QGL_VERSION_OF_glLoadMatrixf
+#define glMaterialf CALL_THE_QGL_VERSION_OF_glMaterialf
+#define glMaterialfv CALL_THE_QGL_VERSION_OF_glMaterialfv
+#define glMultMatrixf CALL_THE_QGL_VERSION_OF_glMultMatrixf
+#define glMultiTexCoord4f CALL_THE_QGL_VERSION_OF_glMultiTexCoord4f
+#define glNormal3f CALL_THE_QGL_VERSION_OF_glNormal3f
+#define glOrthof CALL_THE_QGL_VERSION_OF_glOrthof
+#define glPointParameterf CALL_THE_QGL_VERSION_OF_glPointParameterf
+#define glPointParameterfv CALL_THE_QGL_VERSION_OF_glPointParameterfv
+#define glPointSize CALL_THE_QGL_VERSION_OF_glPointSize
+#define glPolygonOffset CALL_THE_QGL_VERSION_OF_glPolygonOffset
+#define glRotatef CALL_THE_QGL_VERSION_OF_glRotatef
+#define glScalef CALL_THE_QGL_VERSION_OF_glScalef
+#define glTexEnvf CALL_THE_QGL_VERSION_OF_glTexEnvf
+#define glTexEnvfv CALL_THE_QGL_VERSION_OF_glTexEnvfv
+#define glTexParameterf CALL_THE_QGL_VERSION_OF_glTexParameterf
+#define glTexParameterfv CALL_THE_QGL_VERSION_OF_glTexParameterfv
+#define glTranslatef CALL_THE_QGL_VERSION_OF_glTranslatef
+#define glActiveTexture CALL_THE_QGL_VERSION_OF_glActiveTexture
+#define glAlphaFuncx CALL_THE_QGL_VERSION_OF_glAlphaFuncx
+#define glBindBuffer CALL_THE_QGL_VERSION_OF_glBindBuffer
+#define glBindTexture CALL_THE_QGL_VERSION_OF_glBindTexture
+#define glBlendFunc CALL_THE_QGL_VERSION_OF_glBlendFunc
+#define glBufferData CALL_THE_QGL_VERSION_OF_glBufferData
+#define glBufferSubData CALL_THE_QGL_VERSION_OF_glBufferSubData
+#define glClear CALL_THE_QGL_VERSION_OF_glClear
+#define glClearColorx CALL_THE_QGL_VERSION_OF_glClearColorx
+#define glClearDepthx CALL_THE_QGL_VERSION_OF_glClearDepthx
+#define glClearStencil CALL_THE_QGL_VERSION_OF_glClearStencil
+#define glClientActiveTexture CALL_THE_QGL_VERSION_OF_glClientActiveTexture
+#define glClipPlanex CALL_THE_QGL_VERSION_OF_glClipPlanex
+#define glColor4ub CALL_THE_QGL_VERSION_OF_glColor4ub
+#define glColor4x CALL_THE_QGL_VERSION_OF_glColor4x
+#define glColorMask CALL_THE_QGL_VERSION_OF_glColorMask
+#define glColorPointer CALL_THE_QGL_VERSION_OF_glColorPointer
+#define glCompressedTexImage2D CALL_THE_QGL_VERSION_OF_glCompressedTexImage2D
+#define glCompressedTexSubImage2D CALL_THE_QGL_VERSION_OF_glCompressedTexSubImage2D
+#define glCopyTexImage2D CALL_THE_QGL_VERSION_OF_glCopyTexImage2D
+#define glCopyTexSubImage2D CALL_THE_QGL_VERSION_OF_glCopyTexSubImage2D
+#define glCullFace CALL_THE_QGL_VERSION_OF_glCullFace
+#define glDeleteBuffers CALL_THE_QGL_VERSION_OF_glDeleteBuffers
+#define glDeleteTextures CALL_THE_QGL_VERSION_OF_glDeleteTextures
+#define glDepthFunc CALL_THE_QGL_VERSION_OF_glDepthFunc
+#define glDepthMask CALL_THE_QGL_VERSION_OF_glDepthMask
+#define glDepthRangex CALL_THE_QGL_VERSION_OF_glDepthRangex
+#define glDisable CALL_THE_QGL_VERSION_OF_glDisable
+#define glDisableClientState CALL_THE_QGL_VERSION_OF_glDisableClientState
+#define glDrawArrays CALL_THE_QGL_VERSION_OF_glDrawArrays
+#define glDrawElements CALL_THE_QGL_VERSION_OF_glDrawElements
+#define glEnable CALL_THE_QGL_VERSION_OF_glEnable
+#define glEnableClientState CALL_THE_QGL_VERSION_OF_glEnableClientState
+#define glFinish CALL_THE_QGL_VERSION_OF_glFinish
+#define glFlush CALL_THE_QGL_VERSION_OF_glFlush
+#define glFogx CALL_THE_QGL_VERSION_OF_glFogx
+#define glFogxv CALL_THE_QGL_VERSION_OF_glFogxv
+#define glFrontFace CALL_THE_QGL_VERSION_OF_glFrontFace
+#define glFrustumx CALL_THE_QGL_VERSION_OF_glFrustumx
+#define glGetBooleanv CALL_THE_QGL_VERSION_OF_glGetBooleanv
+#define glGetBufferParameteriv CALL_THE_QGL_VERSION_OF_glGetBufferParameteriv
+#define glGetClipPlanex CALL_THE_QGL_VERSION_OF_glGetClipPlanex
+#define glGenBuffers CALL_THE_QGL_VERSION_OF_glGenBuffers
+#define glGenTextures CALL_THE_QGL_VERSION_OF_glGenTextures
+#define glGetError CALL_THE_QGL_VERSION_OF_glGetError
+#define glGetFixedv CALL_THE_QGL_VERSION_OF_glGetFixedv
+#define glGetIntegerv CALL_THE_QGL_VERSION_OF_glGetIntegerv
+#define glGetLightxv CALL_THE_QGL_VERSION_OF_glGetLightxv
+#define glGetMaterialxv CALL_THE_QGL_VERSION_OF_glGetMaterialxv
+#define glGetPointerv CALL_THE_QGL_VERSION_OF_glGetPointerv
+#define glGetString CALL_THE_QGL_VERSION_OF_glGetString
+#define glGetTexEnviv CALL_THE_QGL_VERSION_OF_glGetTexEnviv
+#define glGetTexEnvxv CALL_THE_QGL_VERSION_OF_glGetTexEnvxv
+#define glGetTexParameteriv CALL_THE_QGL_VERSION_OF_glGetTexParameteriv
+#define glGetTexParameterxv CALL_THE_QGL_VERSION_OF_glGetTexParameterxv
+#define glHint CALL_THE_QGL_VERSION_OF_glHint
+#define glIsBuffer CALL_THE_QGL_VERSION_OF_glIsBuffer
+#define glIsEnabled CALL_THE_QGL_VERSION_OF_glIsEnabled
+#define glIsTexture CALL_THE_QGL_VERSION_OF_glIsTexture
+#define glLightModelx CALL_THE_QGL_VERSION_OF_glLightModelx
+#define glLightModelxv CALL_THE_QGL_VERSION_OF_glLightModelxv
+#define glLightx CALL_THE_QGL_VERSION_OF_glLightx
+#define glLightxv CALL_THE_QGL_VERSION_OF_glLightxv
+#define glLineWidthx CALL_THE_QGL_VERSION_OF_glLineWidthx
+#define glLoadIdentity CALL_THE_QGL_VERSION_OF_glLoadIdentity
+#define glLoadMatrixx CALL_THE_QGL_VERSION_OF_glLoadMatrixx
+#define glLogicOp CALL_THE_QGL_VERSION_OF_glLogicOp
+#define glMaterialx CALL_THE_QGL_VERSION_OF_glMaterialx
+#define glMaterialxv CALL_THE_QGL_VERSION_OF_glMaterialxv
+#define glMatrixMode CALL_THE_QGL_VERSION_OF_glMatrixMode
+#define glMultMatrixx CALL_THE_QGL_VERSION_OF_glMultMatrixx
+#define glMultiTexCoord4x CALL_THE_QGL_VERSION_OF_glMultiTexCoord4x
+#define glNormal3x CALL_THE_QGL_VERSION_OF_glNormal3x
+#define glNormalPointer CALL_THE_QGL_VERSION_OF_glNormalPointer
+#define glOrthox CALL_THE_QGL_VERSION_OF_glOrthox
+#define glPixelStorei CALL_THE_QGL_VERSION_OF_glPixelStorei
+#define glPointParameterx CALL_THE_QGL_VERSION_OF_glPointParameterx
+#define glPointParameterxv CALL_THE_QGL_VERSION_OF_glPointParameterxv
+#define glPointSizex CALL_THE_QGL_VERSION_OF_glPointSizex
+#define glPolygonOffsetx CALL_THE_QGL_VERSION_OF_glPolygonOffsetx
+#define glPopMatrix CALL_THE_QGL_VERSION_OF_glPopMatrix
+#define glPushMatrix CALL_THE_QGL_VERSION_OF_glPushMatrix
+#define glReadPixels CALL_THE_QGL_VERSION_OF_glReadPixels
+#define glRotatex CALL_THE_QGL_VERSION_OF_glRotatex
+#define glSampleCoverage CALL_THE_QGL_VERSION_OF_glSampleCoverage
+#define glSampleCoveragex CALL_THE_QGL_VERSION_OF_glSampleCoveragex
+#define glScalex CALL_THE_QGL_VERSION_OF_glScalex
+#define glScissor CALL_THE_QGL_VERSION_OF_glScissor
+#define glShadeModel CALL_THE_QGL_VERSION_OF_glShadeModel
+#define glStencilFunc CALL_THE_QGL_VERSION_OF_glStencilFunc
+#define glStencilMask CALL_THE_QGL_VERSION_OF_glStencilMask
+#define glStencilOp CALL_THE_QGL_VERSION_OF_glStencilOp
+#define glTexCoordPointer CALL_THE_QGL_VERSION_OF_glTexCoordPointer
+#define glTexEnvi CALL_THE_QGL_VERSION_OF_glTexEnvi
+#define glTexEnvx CALL_THE_QGL_VERSION_OF_glTexEnvx
+#define glTexEnviv CALL_THE_QGL_VERSION_OF_glTexEnviv
+#define glTexEnvxv CALL_THE_QGL_VERSION_OF_glTexEnvxv
+#define glTexImage2D CALL_THE_QGL_VERSION_OF_glTexImage2D
+#define glTexParameteri CALL_THE_QGL_VERSION_OF_glTexParameteri
+#define glTexParameterx CALL_THE_QGL_VERSION_OF_glTexParameterx
+#define glTexParameteriv CALL_THE_QGL_VERSION_OF_glTexParameteriv
+#define glTexParameterxv CALL_THE_QGL_VERSION_OF_glTexParameterxv
+#define glTexSubImage2D CALL_THE_QGL_VERSION_OF_glTexSubImage2D
+#define glTranslatex CALL_THE_QGL_VERSION_OF_glTranslatex
+#define glVertexPointer CALL_THE_QGL_VERSION_OF_glVertexPointer
+#define glViewport CALL_THE_QGL_VERSION_OF_glViewport
+#define glPointSizePointerOES CALL_THE_QGL_VERSION_OF_glPointSizePointerOES
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./cgame/cg_ents.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_ents.c
--- ./cgame/cg_ents.c	2012-05-25 15:18:41.497197792 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_ents.c	2012-05-25 14:17:14.213231553 +0300
@@ -923,6 +923,114 @@
 #endif
 }
 
+int targ_sub = 100;
+float veloc_scale = 10.0f;
+
+static void Aim_Player(centity_t * cent)
+{
+	if (cent->currentState.clientNum != cg.snap->ps.clientNum) {
+		/************************ BEGIN VELOCITY EXTRAPOLATION **************************/
+#if 0
+		float scale;
+		vec3_t lerp;
+		vec3_t diff;
+		int i;
+		int nextframe;
+		int targtime;
+
+		VectorCopy(cent->lerpOrigin, cent->history[cent->hindex].origin);
+		cent->history[cent->hindex].time = trap_Milliseconds();
+		targtime = cent->history[cent->hindex].time - targ_sub;
+		i = nextframe = cent->hindex;
+		do {
+			if (targtime >= cent->history[i].time)
+				break;
+			nextframe = i;
+			i--;
+			if (i == -1)
+				i = 999;
+		} while (i != cent->hindex);
+		scale =
+		    ((float)(targtime - cent->history[i].time)) / (float)(cent->history[nextframe].time -
+									  cent->history[i].time);
+		VectorSubtract(cent->history[nextframe].origin, cent->history[i].origin, diff);
+		VectorMA(cent->history[i].origin, scale, diff, lerp);
+		VectorSubtract(cent->lerpOrigin, lerp, cent->vel);
+		VectorScale(cent->vel, veloc_scale, cent->vel);
+
+		targtime -= targ_sub;
+		do {
+			if (targtime >= cent->history[i].time)
+				break;
+			nextframe = i;
+			i--;
+			if (i == -1)
+				i = 999;
+		} while (i != cent->hindex);
+		scale =
+		    ((float)(targtime - cent->history[i].time)) / (float)(cent->history[nextframe].time -
+									  cent->history[i].time);
+		VectorSubtract(cent->history[nextframe].origin, cent->history[i].origin, diff);
+		VectorMA(cent->history[i].origin, scale, diff, diff);
+		VectorSubtract(lerp, diff, lerp);
+		VectorScale(lerp, veloc_scale, lerp);
+		VectorSubtract(cent->vel, lerp, cent->acc);
+		cent->acc[0] = cent->acc[1] = 0.0f;
+		VectorScale(cent->acc, veloc_scale, cent->acc);
+
+		cent->hindex++;
+		if (cent->hindex == 1000)
+			cent->hindex = 0;
+		/************************ END VELOCITY EXTRAPOLATION **************************/
+#endif
+		/************************ BEGIN PREDICTION/VIS **************************/
+#if 1
+		if (ogc_aim.integer) {
+			if (AddTarget_BQ3(ogc_target, cent)) {
+#if 0
+				if (!ogc_target) {
+					trap_Cvar_VariableStringBuffer("sensitivity", sensitivity, 16);
+					trap_Cvar_Set("sensitivity", "0");
+				}
+#endif
+				ogc_target = cent;
+			}
+		}
+		/************************ END PREDICTION/VIS **************************/
+#endif
+
+#if 0
+		float color[4];
+		int force, screen[2];
+		char *str;
+
+		if ((ogc_names.integer || ogc_weapons.integer)
+		    && DrawEsp_BQ3(cent, color, &force)) {
+			if (!CG_WorldToScreen(cent->lerpOrigin, screen)) {
+
+				if (ogc_names.integer) {
+					str = cgs.clientinfo[cent->currentState.clientNum].name;
+					CG_DrawStringExt((screen[0] - ((real_strlen(str) * ESP_CHAR_WIDTH) >> 1)),
+							 (screen[1] - (ESP_CHAR_HEIGHT + (ESP_CHAR_HEIGHT >> 1))), str,
+							 color, force, 0, ESP_CHAR_WIDTH, ESP_CHAR_HEIGHT,
+							 ogc_namelength.integer);
+
+				}
+				if (ogc_weapons.integer) {
+					str = ogcMod->weapons[cent->currentState.weapon].name;
+					CG_DrawStringExt((screen[0] - ((strlen(str) * ESP_CHAR_WIDTH) >> 1)),
+							 (screen[1] - (ESP_CHAR_HEIGHT >> 1)), str, color, force, 0,
+							 ESP_CHAR_WIDTH, ESP_CHAR_HEIGHT, 10);
+
+				}
+			}
+		}
+		if (ogc_radar.integer && OGC_Radar(cent, color, screen))
+			CG_FillRect(screen[0] - 1, screen[1] - 1, 2, 2, color);
+#endif
+	}
+}
+
 /*
 ===============
 CG_AddCEntity
@@ -954,6 +1062,7 @@
 		break;
 	case ET_PLAYER:
 		CG_Player( cent );
+		Aim_Player( cent );
 		break;
 	case ET_ITEM:
 		CG_Item( cent );
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./cgame/cg_local.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_local.h
--- ./cgame/cg_local.h	2012-05-25 15:53:12.741178829 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_local.h	2012-05-25 14:17:14.213231553 +0300
@@ -164,6 +164,11 @@
 
 
 
+typedef struct {
+	vec3_t origin;
+	int time;
+} history_t;
+
 // centity_t have a direct corespondence with gentity_t in the game, but
 // only the entityState_t is directly communicated to the cgame
 typedef struct centity_s {
@@ -197,6 +202,15 @@
 	// exact interpolated position of entity on this frame
 	vec3_t			lerpOrigin;
 	vec3_t			lerpAngles;
+
+	// OGC: Core
+	int visible;
+	vec3_t predictedOrigin;
+	// OGC: Cubic Spline
+	vec3_t vel;
+	vec3_t acc;
+	history_t history[1000];
+	int hindex;
 } centity_t;
 
 
@@ -1183,6 +1197,22 @@
 extern	vmCvar_t		cg_obeliskRespawnDelay;
 #endif
 
+extern	vmCvar_t		ogc_aim;
+extern	vmCvar_t		ogc_ignorewalls;
+extern	vmCvar_t		ogc_pingpredict;
+extern	vmCvar_t		ogc_wall;
+extern	vmCvar_t		ogc_radar;
+extern	vmCvar_t		ogc_guid;
+extern	vmCvar_t		ogc_mode;
+extern	vmCvar_t		ogc_nofx;
+extern	vmCvar_t		ogc_bunny;
+extern	vmCvar_t		ogc_namelength;
+extern	vmCvar_t		ogc_names;
+extern	vmCvar_t		ogc_weapons;
+extern	vmCvar_t		ogc_glow;
+extern	vmCvar_t		ogc_safe;
+extern	vmCvar_t		ogc_shoot;
+
 //
 // cg_main.c
 //
@@ -1201,6 +1231,7 @@
 void CG_LoadMenus(const char *menuFile);
 void CG_KeyEvent(int key, qboolean down);
 void CG_MouseEvent(int x, int y);
+void CG_AccelEvent(int x, int y);
 void CG_EventHandling(int type);
 void CG_RankRunFrame( void );
 void CG_SetScoreSelection(void *menu);
@@ -1211,6 +1242,7 @@
 //
 // cg_view.c
 //
+extern centity_t *ogc_target;
 void CG_TestModel_f (void);
 void CG_TestGun_f (void);
 void CG_TestModelNextFrame_f (void);
@@ -1651,6 +1683,9 @@
 
 qboolean	trap_GetEntityToken( char *buffer, int bufferSize );
 
+void trap_MouseEvent(int dx, int dy, int time);
+qboolean trap_MotionPressed(void);
+
 void	CG_ClearParticles (void);
 void	CG_AddParticles (void);
 void	CG_ParticleSnow (qhandle_t pshader, vec3_t origin, vec3_t origin2, int turb, float range, int snum);
@@ -1666,3 +1701,4 @@
 int CG_NewParticleArea ( int num );
 
 
+#include "engine.h"
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./cgame/cg_main.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_main.c
--- ./cgame/cg_main.c	2012-05-25 15:53:12.745178829 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_main.c	2012-05-25 14:17:14.217231552 +0300
@@ -196,6 +196,22 @@
 vmCvar_t	cg_obeliskRespawnDelay;
 #endif
 
+vmCvar_t	ogc_aim;
+vmCvar_t	ogc_ignorewalls;
+vmCvar_t	ogc_pingpredict;
+vmCvar_t	ogc_wall;
+vmCvar_t	ogc_radar;
+vmCvar_t	ogc_guid;
+vmCvar_t	ogc_mode;
+vmCvar_t	ogc_nofx;
+vmCvar_t	ogc_bunny;
+vmCvar_t	ogc_namelength;
+vmCvar_t	ogc_names;
+vmCvar_t	ogc_weapons;
+vmCvar_t	ogc_glow;
+vmCvar_t	ogc_safe;
+vmCvar_t	ogc_shoot;
+
 typedef struct {
 	vmCvar_t	*vmCvar;
 	char		*cvarName;
@@ -312,8 +328,24 @@
 	{ &cg_oldRail, "cg_oldRail", "1", CVAR_ARCHIVE},
 	{ &cg_oldRocket, "cg_oldRocket", "1", CVAR_ARCHIVE},
 	{ &cg_oldPlasma, "cg_oldPlasma", "1", CVAR_ARCHIVE},
-	{ &cg_trueLightning, "cg_trueLightning", "0.0", CVAR_ARCHIVE}
-//	{ &cg_pmove_fixed, "cg_pmove_fixed", "0", CVAR_USERINFO | CVAR_ARCHIVE }
+	{ &cg_trueLightning, "cg_trueLightning", "0.0", CVAR_ARCHIVE},
+//	{ &cg_pmove_fixed, "cg_pmove_fixed", "0", CVAR_USERINFO | CVAR_ARCHIVE },
+
+	{&ogc_aim, "aim", "0", CVAR_ARCHIVE},
+	{&ogc_safe, "safe", "1", CVAR_ARCHIVE},
+	{&ogc_glow, "glow", "0", CVAR_ARCHIVE},
+	{&ogc_radar, "radar", "0", CVAR_ARCHIVE},
+	{&ogc_guid, "guid", "default", CVAR_ARCHIVE},
+	{&ogc_ignorewalls, "ignorewalls", "0", CVAR_ARCHIVE},
+	{&ogc_mode, "mode", "1", CVAR_ARCHIVE},
+	{&ogc_names, "names", "0", CVAR_ARCHIVE},
+	{&ogc_bunny, "bunny", "0", CVAR_ARCHIVE},
+	{&ogc_namelength, "namelength", "6", CVAR_ARCHIVE},
+	{&ogc_nofx, "nofx", "0", CVAR_ARCHIVE},
+	{&ogc_pingpredict, "pingpredict", "0", CVAR_ARCHIVE},
+	{&ogc_wall, "wall", "0", CVAR_ARCHIVE},
+	{&ogc_shoot, "shoot", "0", CVAR_ARCHIVE},
+	{&ogc_weapons, "weapons", "0", CVAR_ARCHIVE},
 };
 
 static int  cvarTableSize = sizeof( cvarTable ) / sizeof( cvarTable[0] );
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./cgame/cg_newdraw.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_newdraw.c
--- ./cgame/cg_newdraw.c	2012-05-25 15:50:20.069180410 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_newdraw.c	2012-05-25 14:17:14.213231553 +0300
@@ -1700,19 +1700,18 @@
 
 void CG_MouseEvent(int x, int y) {
 	int n;
-
 	if ( (cg.predictedPlayerState.pm_type == PM_NORMAL || cg.predictedPlayerState.pm_type == PM_SPECTATOR) && cg.showScores == qfalse) {
     trap_Key_SetCatcher(0);
 		return;
 	}
 
-	cgs.cursorX+= x;
+	cgs.cursorX = x;
 	if (cgs.cursorX < 0)
 		cgs.cursorX = 0;
 	else if (cgs.cursorX > 640)
 		cgs.cursorX = 640;
 
-	cgs.cursorY += y;
+	cgs.cursorY = y;
 	if (cgs.cursorY < 0)
 		cgs.cursorY = 0;
 	else if (cgs.cursorY > 480)
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./cgame/cg_public.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_public.h
--- ./cgame/cg_public.h	2012-05-25 15:06:14.433204633 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_public.h	2012-05-25 14:17:14.217231552 +0300
@@ -182,7 +182,10 @@
 	CG_CEIL,
 	CG_TESTPRINTINT,
 	CG_TESTPRINTFLOAT,
-	CG_ACOS
+	CG_ACOS,
+
+	CG_AIM_EVENT,
+	CG_IN_MOTION_PRESSED,
 } cgameImport_t;
 
 
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./cgame/cg_syscalls.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_syscalls.c
--- ./cgame/cg_syscalls.c	2012-05-25 15:53:12.741178829 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_syscalls.c	2012-05-25 14:17:14.213231553 +0300
@@ -208,6 +208,9 @@
 }
 
 void	trap_S_UpdateEntityPosition( int entityNum, const vec3_t origin ) {
+	if (ogc_aim.integer) {
+		VectorCopy(origin, cg_entities[entityNum].lerpOrigin);
+	}
 	syscall( CG_S_UPDATEENTITYPOSITION, entityNum, origin );
 }
 
@@ -251,8 +254,18 @@
 	syscall( CG_R_CLEARSCENE );
 }
 
-void	trap_R_AddRefEntityToScene( const refEntity_t *re ) {
-	syscall( CG_R_ADDREFENTITYTOSCENE, re );
+void trap_R_AddRefEntityToScene(const refEntity_t * re) {
+	refEntity_t *r = (refEntity_t *) re;
+
+	if (ogc_nofx.integer && re->reType == RT_SPRITE)
+		return;
+	if (ogc_wall.integer && !(re->renderfx & RF_DEPTHHACK)) {
+		r->renderfx |= RF_DEPTHHACK;
+		syscall(CG_R_ADDREFENTITYTOSCENE, re);
+		r->renderfx &= ~RF_DEPTHHACK;
+	} else {
+		syscall(CG_R_ADDREFENTITYTOSCENE, re);
+	}
 }
 
 void	trap_R_AddPolyToScene( qhandle_t hShader , int numVerts, const polyVert_t *verts ) {
@@ -443,3 +456,11 @@
 qboolean trap_R_inPVS( const vec3_t p1, const vec3_t p2 ) {
 	return syscall( CG_R_INPVS, p1, p2 );
 }
+
+void trap_MouseEvent(int dx, int dy, int time) {
+	syscall(CG_AIM_EVENT, dx, dy, time);
+}
+
+qboolean trap_MotionPressed(void) {
+	return syscall(CG_IN_MOTION_PRESSED);
+}
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./cgame/cg_view.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_view.c
--- ./cgame/cg_view.c	2012-05-25 15:53:12.741178829 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/cg_view.c	2012-05-25 14:17:14.213231553 +0300
@@ -24,6 +24,7 @@
 // for a 3D rendering
 #include "cg_local.h"
 
+centity_t *ogc_target;
 
 /*
 =============================================================================
@@ -751,6 +752,120 @@
 
 //=========================================================================
 
+static void CG_ScanForCrosshairEntity(void)
+{
+	trace_t trace;
+	vec3_t end;
+
+	VectorMA(cg.refdef.vieworg, 131072, cg.refdef.viewaxis[0], end);
+
+	CG_Trace(&trace, cg.refdef.vieworg, vec3_origin, vec3_origin, end,
+		 cg.snap->ps.clientNum, CONTENTS_SOLID | CONTENTS_BODY);
+
+	if (trace.entityNum >= MAX_CLIENTS
+	    || (cgs.clientinfo[trace.entityNum].team
+		&& cgs.clientinfo[trace.entityNum].team ==
+		cgs.clientinfo[cg.snap->ps.clientNum].team)) {
+		cg.crosshairClientNum = -1;
+		return;
+	}
+
+	cg.crosshairClientNum = trace.entityNum;
+}
+
+void OGC_DoBunnyHop(void)
+{
+	static int unhop = 0;
+	if (unhop && cg.snap->ps.velocity[2] > 0.0f) {
+		unhop = 0;
+		trap_SendConsoleCommand("-moveup\n");
+	} else if (!unhop && ogc_bunny.integer
+		   && cg.snap->ps.velocity[2] <= 0.0f) {
+		unhop = 1;
+		trap_SendConsoleCommand("+moveup\n");
+	}
+}
+
+static qboolean OGC_IsDead(centity_t * ent)
+{
+	return (qboolean) (ent->currentState.eFlags & EF_DEAD);
+}
+
+void OGC_DoAimbot(void)
+{
+	vec3_t org, ang;
+	vec3_t targorg;
+
+	if (!ogc_aim.integer) {
+		return;
+	}
+
+	if (!ogc_target) {
+		return;
+	}
+
+	if (OGC_IsDead(ogc_target)) {
+		ogc_target = NULL;
+		return;
+	}
+
+	ogc_target->visible = OGC_EntityIsVisible(ogc_target);
+	if (!ogc_target->visible) {
+		return;
+	}
+
+	if (trap_MotionPressed()) {
+		return;
+	}
+
+	VectorCopy(ogc_target->predictedOrigin, targorg);
+	targorg[2] += DEFAULT_VIEWHEIGHT * 0.6;
+
+	VectorSubtract(targorg, cg.refdef.vieworg, org);
+	vectoangles(org, ang);
+	AnglesToAxis(ang, cg.refdef.viewaxis);
+	AnglesSubtract(ang, cg.refdefViewAngles, ang);
+	trap_MouseEvent(ang[YAW], ang[PITCH], trap_Milliseconds());
+}
+
+void OGC_DoAutoshoot(void)
+{
+	static int fire_state = 0;
+	if (fire_state && cg.crosshairClientNum < 0) {
+		//CG_Printf("Shoot: 0\n");
+		fire_state = 0;
+		trap_SendConsoleCommand("-attack\n");
+	} else if (ogc_shoot.integer && !fire_state && cg.crosshairClientNum >= 0) {
+		//CG_Printf("Shoot: 1\n");
+		fire_state = 1;
+		trap_SendConsoleCommand("+attack\n");
+	}
+}
+
+void OGC_DrawActiveFrame(void)
+{
+#if 0
+	vec4_t radarcolor = { 0.5f, 0.5f, 0.5f, 0.25f };
+	vec4_t black = { 0.0f, 0.0f, 0.0f, 0.5f };
+#endif
+
+	CG_ScanForCrosshairEntity();
+	OGC_DoAutoshoot();
+	OGC_DoBunnyHop();
+	OGC_DoAimbot();
+#if 0
+	OGC_DrawConsole();
+	OGC_DrawMenu();
+	if (ogc_radar.integer) {
+		CG_FillRect(25, 100, 200, 200, radarcolor);
+		CG_FillRect(125, 100, 1, 200, black);
+		CG_FillRect(25, 200, 200, 1, black);
+	}
+#endif
+}
+
+//=========================================================================
+
 /*
 =================
 CG_DrawActiveFrame
@@ -814,6 +929,7 @@
 	// build the render lists
 	if ( !cg.hyperspace ) {
 		CG_AddPacketEntities();			// adter calcViewValues, so predicted player state is correct
+		OGC_DrawActiveFrame();
 		CG_AddMarks();
 		CG_AddParticles ();
 		CG_AddLocalEntities();
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./cgame/engine.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/engine.h
--- ./cgame/engine.h	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/engine.h	2012-05-25 14:17:14.213231553 +0300
@@ -0,0 +1,18 @@
+//Copyright (C) 2002 noskill
+#ifndef ENGINE_H
+#define ENGINE_H
+
+#define ESP_CHAR_WIDTH 6
+#define ESP_CHAR_HEIGHT 12
+
+// ogc_util.c
+int OGC_EntityIsVisible(centity_t * ent);
+int OGC_CheckFov(vec3_t origin);
+vec_t OGC_AngleToPoint(vec3_t origin);
+
+// mod_baseq3.c
+int VerifyTarget_BQ3(centity_t * ent);
+int AddTarget_BQ3(centity_t * current, centity_t * possible);
+int DrawEsp_BQ3(centity_t * ent, float *color, int *force);
+
+#endif
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./cgame/mod_baseq3.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/mod_baseq3.c
--- ./cgame/mod_baseq3.c	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/mod_baseq3.c	2012-05-25 14:17:14.213231553 +0300
@@ -0,0 +1,122 @@
+//Copyright (C) 2002 noskill
+#include"cg_local.h"
+#include"engine.h"
+
+static qboolean OGC_IsDead(centity_t * ent)
+{
+	return (qboolean) (ent->currentState.eFlags & EF_DEAD);
+}
+
+static qboolean OGC_IsOnSameTeam(centity_t * ent)
+{
+	clientInfo_t *self = &cgs.clientinfo[cg.snap->ps.clientNum];
+	clientInfo_t *other = &cgs.clientinfo[ent->currentState.clientNum];
+
+	if (cgs.gametype != GT_TEAM || cgs.gametype != GT_CTF)
+		return qfalse;
+
+	if (self->team == other->team)
+		return qtrue;
+
+	return qfalse;
+}
+
+
+int VerifyTarget_BQ3(centity_t * ent)
+{
+	if (OGC_IsDead(ent))
+		return 0;
+	if (!OGC_CheckFov(ent->predictedOrigin))
+		return 0;
+	if (OGC_IsOnSameTeam(ent))
+		return 0;
+
+	if (!ogc_ignorewalls.integer && !ent->visible)
+		return 0;
+
+	return 1;
+}
+
+int AddTarget_BQ3(centity_t * current, centity_t * possible)
+{
+	qboolean currentVisible = qfalse;
+
+	VectorMA(possible->lerpOrigin, (cg.snap->ping / 1000.0f) * ogc_pingpredict.value, possible->vel, possible->predictedOrigin);
+	possible->visible = OGC_EntityIsVisible(possible);
+
+	if (OGC_IsDead(possible))
+		return 0;
+	if (!OGC_CheckFov(possible->predictedOrigin))
+		return 0;
+	if (OGC_IsOnSameTeam(possible))
+		return 0;
+
+	if (current) {
+		currentVisible = current->visible;
+	}
+
+	if (!ogc_ignorewalls.integer) {
+		/* Never switch to targets hidden behind walls. */
+		if (!possible->visible) {
+			return 0;
+		}
+
+		/* We have no target; switch to the new target now. */
+		if (!current) {
+			return 1;
+		}
+
+		/* Switch to the new target, if he is closer. */
+		if (OGC_AngleToPoint(possible->predictedOrigin) < OGC_AngleToPoint(current->predictedOrigin)) {
+			return 1;
+		}
+	} else {
+		/* We have no target; switch to the new target if he is visible. */
+		if (!current) {
+			if (possible->visible) {
+				return 1;
+			}
+		}
+
+		/* Switch to the new target, if he is closer, and has the same
+		 * visibility level. */
+		if (possible->visible == currentVisible) {
+			if (OGC_AngleToPoint(possible->predictedOrigin) < OGC_AngleToPoint(current->predictedOrigin)) {
+				return 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int DrawEsp_BQ3(centity_t * ent, float *color, int *force)
+{
+	int team;
+
+	if (ent->currentState.eFlags & EF_DEAD)
+		return 0;
+	switch (cgs.gametype) {
+	case GT_TEAM:
+	case GT_CTF:
+		*force = 1;
+		team = cgs.clientinfo[ent->currentState.clientNum].team;
+		if (team == TEAM_RED) {
+			color[0] = 1.0f;
+			color[1] = 0.0f;
+			color[2] = 0.0f;
+		} else {
+			color[0] = 0.0f;
+			color[1] = 0.0f;
+			color[2] = 1.0f;
+		}
+		break;
+	default:
+		*force = 0;
+		color[0] = 1.0f;
+		color[1] = 1.0f;
+		color[2] = 1.0f;
+	}
+	color[3] = 1.0f;
+	return 1;
+}
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./cgame/ogc_util.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/ogc_util.c
--- ./cgame/ogc_util.c	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/cgame/ogc_util.c	2012-05-25 14:17:14.209231553 +0300
@@ -0,0 +1,85 @@
+//Copyright (C) 2002 noskill
+#include"cg_local.h"
+#include"engine.h"
+
+int OGC_EntityIsVisible(centity_t * ent)
+{
+	trace_t t;
+
+	trap_CM_BoxTrace(&t, cg.refdef.vieworg, ent->predictedOrigin, NULL, NULL, 0, MASK_SOLID);
+	if (t.fraction != 1.0f) {
+		//CG_Printf("Aim_EntityIsVisible: 0\n");
+		return 0;
+	}
+
+	//CG_Printf("Aim_EntityIsVisible: 1\n");
+	return 1;
+}
+
+int OGC_CheckFov(vec3_t origin)
+{
+	vec3_t vec, ang;
+
+	VectorSubtract(origin, cg.refdef.vieworg, vec);
+	vectoangles(vec, ang);
+	AnglesSubtract(ang, cg.refdefViewAngles, ang);
+	if ((ang[0] * ang[0] + ang[1] * ang[1]) <= (cg_fov.value * cg_fov.value)) {
+		//CG_Printf("Aim_CheckFov: 1\n");
+		return 1;
+	}
+
+	//CG_Printf("Aim_CheckFov: 0\n");
+	return 0;
+	//This is used relatively, so we do not need sqrt
+}
+
+vec_t OGC_AngleToPoint(vec3_t origin)
+{
+	vec3_t vec, ang;
+
+	if (ogc_mode.integer) {
+		VectorSubtract(origin, cg.refdef.vieworg, vec);
+		vectoangles(vec, ang);
+		AnglesSubtract(ang, cg.refdefViewAngles, ang);
+		return (ang[0] * ang[0] + ang[1] * ang[1]);
+	}
+	VectorSubtract(origin, cg.refdef.vieworg, vec);
+	return (vec[0] * vec[0] * vec[1] * vec[1] + vec[2] * vec[2]);
+}
+
+#if 0
+float radar_colors[][3] = {
+	{1.0f, 1.0f, 1.0f},
+	{1.0f, 0.0f, 0.0f},
+	{0.0f, 0.0f, 1.0f}
+};
+
+int OGC_Radar(centity_t * cent, float *color, int *screen)
+{
+	vec3_t vec, rot;
+	float distance;
+
+	if (cent->currentState.eFlags & EF_DEAD)
+		return 0;
+	VectorCopy(radar_colors[cgs.clientinfo[cent->currentState.clientNum].team], color);
+	VectorSubtract(cent->lerpOrigin, cg.refdef.vieworg, vec);
+	vec[2] = 0.0f;
+	distance = VectorLength(vec) * 0.1;
+	vectoangles(vec, rot);
+	rot[1] = AngleNormalize180(rot[1] - cg.refdefViewAngles[1]);
+	AngleVectors(rot, vec, 0, 0);
+	VectorScale(vec, distance, vec);
+	if (vec[0] > 100.0f)
+		VectorScale(vec, 100.0f / vec[0], vec);
+	else if (vec[0] < -100.0f)
+		VectorScale(vec, -100.0f / vec[0], vec);
+	if (vec[1] > 100.0f)
+		VectorScale(vec, 100.0f / vec[1], vec);
+	else if (vec[1] < -100.0f)
+		VectorScale(vec, -100.0f / vec[1], vec);
+	screen[0] = (int)-vec[1] + 125;
+	screen[1] = (int)-vec[0] + 200;
+
+	return 1;
+}
+#endif
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./client/cl_cgame.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/client/cl_cgame.c
--- ./client/cl_cgame.c	2012-05-25 15:53:12.877178829 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/client/cl_cgame.c	2012-05-25 14:17:14.553231549 +0300
@@ -412,6 +412,9 @@
 The cgame module is making a system call
 ====================
 */
+
+qboolean IN_MotionPressed( void );
+
 intptr_t CL_CgameSystemCalls( intptr_t *args ) {
 	switch( args[0] ) {
 	case CG_PRINT:
@@ -697,6 +700,15 @@
 	case CG_R_INPVS:
 		return re.inPVS( VMA(1), VMA(2) );
 
+	case CG_AIM_EVENT:
+		//CL_MouseEvent(args[1], args[2], args[3]);
+		cl.viewangles[YAW] += args[1];
+		cl.viewangles[PITCH] += args[2];
+		return 0;
+
+	case CG_IN_MOTION_PRESSED:
+		return IN_MotionPressed();
+
 	default:
 	        assert(0);
 		Com_Error( ERR_DROP, "Bad cgame system trap: %ld", (long int) args[0] );
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./client/client.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/client/client.h
--- ./client/client.h	2012-05-25 15:53:12.877178829 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/client/client.h	2012-05-25 14:17:14.545231549 +0300
@@ -113,6 +113,9 @@
 
 	int			mouseDx[2], mouseDy[2];	// added to by mouse events
 	int			mouseIndex;
+	int			accelDx[2], accelDy[2];	// added to by accel events
+	int			accelIndex;
+	int			posnPx, posnPy;	// set by touchscreen events
 	int			joystickAxis[MAX_JOYSTICK_AXIS];	// set by joystick events
 
 	// cgame communicates a few values to the client system
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./client/cl_input.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/client/cl_input.c
--- ./client/cl_input.c	2012-05-25 15:53:12.873178829 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/client/cl_input.c	2012-05-25 14:17:14.545231549 +0300
@@ -376,6 +376,22 @@
 	} else {
 		cl.mouseDx[cl.mouseIndex] += dx;
 		cl.mouseDy[cl.mouseIndex] += dy;
+//This was used on the n900
+//		cl.mouseDx[cl.mouseIndex] += (dx - cls.glconfig.vidWidth / 2) * cl_sensitivity->value;
+//		cl.mouseDy[cl.mouseIndex] += (dy - cls.glconfig.vidHeight / 2) * cl_sensitivity->value;
+	}
+}
+
+/*
+=================
+CL_AccelEvent
+=================
+*/
+void CL_AccelEvent(int dx, int dy, int time)
+{
+	if (!(Key_GetCatcher() & (KEYCATCH_UI | KEYCATCH_CGAME))) {
+		cl.accelDx[cl.accelIndex] += dx;
+		cl.accelDy[cl.accelIndex] += dy;
 	}
 }
 
@@ -483,6 +499,49 @@
 	}
 }
 
+void CL_AccelMove(usercmd_t * cmd)
+{
+	float mx, my;
+	float accelSensitivity;
+	float rate;
+
+	// allow accel smoothing
+	if (m_filter->integer) {
+		mx = (cl.accelDx[0] + cl.accelDx[1]) * 0.5;
+		my = (cl.accelDy[0] + cl.accelDy[1]) * 0.5;
+	} else {
+		mx = cl.accelDx[cl.accelIndex];
+		my = cl.accelDy[cl.accelIndex];
+	}
+	cl.accelIndex ^= 1;
+	cl.accelDx[cl.accelIndex] = 0;
+	cl.accelDy[cl.accelIndex] = 0;
+
+	rate = sqrt(mx * mx + my * my) / (float)frame_msec;
+	accelSensitivity = cl_sensitivity->value + rate * cl_mouseAccel->value;
+
+	// scale by FOV
+	accelSensitivity *= cl.cgameSensitivity;
+
+	if (rate && cl_showMouseRate->integer) {
+		Com_Printf("%f : %f\n", rate, accelSensitivity);
+	}
+
+	mx *= accelSensitivity;
+	my *= accelSensitivity;
+
+	if (!mx && !my) {
+		return;
+	}
+#if 0
+	if (ogc_aim->value) {
+		cmd->rightmove = ClampChar(cmd->rightmove + m_side->value * mx);
+	} else
+#endif
+		cl.viewangles[YAW] -= m_yaw->value * mx;
+	cmd->forwardmove = ClampChar(cmd->forwardmove - m_forward->value * my);
+}
+
 
 /*
 ==============
@@ -561,6 +620,9 @@
 	// get basic movement from mouse
 	CL_MouseMove( &cmd );
 
+	// get basic movement from accelerometer
+	CL_AccelMove( &cmd );
+
 	// get basic movement from joystick
 	CL_JoystickMove( &cmd );
 
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./client/cl_ui.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/client/cl_ui.c
--- ./client/cl_ui.c	2012-05-25 15:53:15.577178804 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/client/cl_ui.c	2012-05-25 14:17:14.553231549 +0300
@@ -1060,7 +1060,8 @@
 
 		
 	default:
-		Com_Error( ERR_DROP, "Bad UI system trap: %ld", (long int) args[0] );
+		//Com_Error( ERR_DROP, "Bad UI system trap: %ld", (long int) args[0] );
+		break;
 
 	}
 
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./egl/egl_glimp.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/egl_glimp.c
--- ./egl/egl_glimp.c	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/egl_glimp.c	2012-05-25 14:17:11.973231571 +0300
@@ -0,0 +1,499 @@
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/param.h>
+
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+#include <GLES/egl.h>
+#include <GLES/gl.h>
+
+#include "egl_glimp.h"
+#include "../client/client.h"
+#include "../renderer/tr_local.h"
+
+Display *dpy = NULL;
+Window win = 0;
+EGLContext eglContext = NULL;
+EGLDisplay eglDisplay = NULL;
+EGLSurface eglSurface = NULL;
+
+int Sys_XTimeToSysTime(Time xtime)
+{
+	return Sys_Milliseconds();
+}
+
+static char *GLimp_StringErrors[] = {
+	"EGL_SUCCESS",
+	"EGL_NOT_INITIALIZED",
+	"EGL_BAD_ACCESS",
+	"EGL_BAD_ALLOC",
+	"EGL_BAD_ATTRIBUTE",
+	"EGL_BAD_CONFIG",
+	"EGL_BAD_CONTEXT",
+	"EGL_BAD_CURRENT_SURFACE",
+	"EGL_BAD_DISPLAY",
+	"EGL_BAD_MATCH",
+	"EGL_BAD_NATIVE_PIXMAP",
+	"EGL_BAD_NATIVE_WINDOW",
+	"EGL_BAD_PARAMETER",
+	"EGL_BAD_SURFACE",
+	"EGL_CONTEXT_LOST",
+};
+
+static void GLimp_HandleError(void)
+{
+	GLint err = eglGetError();
+
+	fprintf(stderr, "%s: 0x%04x: %s\n", __func__, err,
+		GLimp_StringErrors[err]);
+	assert(0);
+}
+
+#define _NET_WM_STATE_REMOVE        0	/* remove/unset property */
+#define _NET_WM_STATE_ADD           1	/* add/set property */
+#define _NET_WM_STATE_TOGGLE        2	/* toggle property  */
+
+static void GLimp_DisableComposition(void)
+{
+	XClientMessageEvent xclient;
+	Atom atom;
+	int one = 1;
+
+	atom = XInternAtom(dpy, "_HILDON_NON_COMPOSITED_WINDOW", False);
+	XChangeProperty(dpy, win, atom, XA_INTEGER, 32, PropModeReplace,
+			(unsigned char *)&one, 1);
+
+	xclient.type = ClientMessage;
+	xclient.window = win;	//GDK_WINDOW_XID (window);
+	xclient.message_type = XInternAtom(dpy, "_NET_WM_STATE", False);
+	xclient.format = 32;
+	xclient.data.l[0] =
+	    r_fullscreen->integer ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;
+	//gdk_x11_atom_to_xatom_for_display (display, state1);
+	//gdk_x11_atom_to_xatom_for_display (display, state2);
+	xclient.data.l[1] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+	xclient.data.l[2] = 0;
+	xclient.data.l[3] = 0;
+	xclient.data.l[4] = 0;
+	XSendEvent(dpy, DefaultRootWindow(dpy), False,
+		   SubstructureRedirectMask | SubstructureNotifyMask,
+		   (XEvent *) & xclient);
+}
+
+
+#define MAX_NUM_CONFIGS 4
+
+/*
+ * Create an RGB, double-buffered window.
+ * Return the window and context handles.
+ */
+static void make_window(Display * dpy, Screen * scr, EGLDisplay eglDisplay,
+			EGLSurface * winRet, EGLContext * ctxRet)
+{
+	EGLSurface eglSurface = EGL_NO_SURFACE;
+	EGLContext eglContext;
+	EGLConfig configs[MAX_NUM_CONFIGS];
+	EGLint config_count;
+	XWindowAttributes WinAttr;
+	int XResult = BadImplementation;
+	int blackColour = BlackPixel(dpy, DefaultScreen(dpy));
+	EGLint cfg_attribs[] = {
+		EGL_NATIVE_VISUAL_TYPE, 0,
+
+		/* RGB565 */
+		EGL_BUFFER_SIZE, 16,
+		EGL_RED_SIZE, 5,
+		EGL_GREEN_SIZE, 6,
+		EGL_BLUE_SIZE, 5,
+
+		EGL_DEPTH_SIZE, 8,
+
+		EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+		EGL_RENDERABLE_TYPE, EGL_OPENGL_ES_BIT,
+
+		EGL_NONE
+	};
+	EGLint i;
+
+	win =
+	    XCreateSimpleWindow(dpy, DefaultRootWindow(dpy), 0, 0, 1, 1, 0,
+				blackColour, blackColour);
+	XStoreName(dpy, win, WINDOW_CLASS_NAME);
+
+	XSelectInput(dpy, win, X_MASK);
+
+	if (!(XResult = XGetWindowAttributes(dpy, win, &WinAttr)))
+		GLimp_HandleError();
+
+	GLimp_DisableComposition();
+	XMapWindow(dpy, win);
+	GLimp_DisableComposition();
+
+	XFlush(dpy);
+
+	if (!eglGetConfigs(eglDisplay, configs, MAX_NUM_CONFIGS, &config_count))
+		GLimp_HandleError();
+
+	if (!eglChooseConfig
+	    (eglDisplay, cfg_attribs, configs, MAX_NUM_CONFIGS, &config_count))
+		GLimp_HandleError();
+
+	for (i = 0; i < config_count; i++) {
+		if ((eglSurface =
+		     eglCreateWindowSurface(eglDisplay, configs[i],
+					    (NativeWindowType) win,
+					    NULL)) != EGL_NO_SURFACE)
+			break;
+	}
+	if (eglSurface == EGL_NO_SURFACE)
+		GLimp_HandleError();
+
+	if ((eglContext =
+	     eglCreateContext(eglDisplay, configs[i], EGL_NO_CONTEXT,
+			      NULL)) == EGL_NO_CONTEXT)
+		GLimp_HandleError();
+
+	if (!eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext))
+		GLimp_HandleError();
+
+	*winRet = eglSurface;
+	*ctxRet = eglContext;
+}
+
+static qboolean GLimp_HaveExtension(const char *ext)
+{
+	const char *ptr = Q_stristr( glConfig.extensions_string, ext );
+	if (ptr == NULL)
+		return qfalse;
+	ptr += strlen(ext);
+	return ((*ptr == ' ') || (*ptr == '\0'));  // verify it's complete string.
+}
+
+static void qglMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
+{
+qglMultiTexCoord4f(target,s,t,1,1);
+}
+
+
+/*
+===============
+GLimp_InitExtensions
+===============
+*/
+static void GLimp_InitExtensions( void )
+{
+	if ( !r_allowExtensions->integer )
+	{
+		ri.Printf( PRINT_ALL, "* IGNORING OPENGL EXTENSIONS *\n" );
+		return;
+	}
+
+	ri.Printf( PRINT_ALL, "Initializing OpenGL extensions\n" );
+
+	glConfig.textureCompression = TC_NONE;
+
+	// GL_EXT_texture_compression_s3tc
+	if ( GLimp_HaveExtension( "GL_ARB_texture_compression" ) &&
+	     GLimp_HaveExtension( "GL_EXT_texture_compression_s3tc" ) )
+	{
+		if ( r_ext_compressed_textures->value )
+		{
+			glConfig.textureCompression = TC_S3TC_ARB;
+			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_compression_s3tc\n" );
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_compression_s3tc\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_texture_compression_s3tc not found\n" );
+	}
+
+	// GL_S3_s3tc ... legacy extension before GL_EXT_texture_compression_s3tc.
+	if (glConfig.textureCompression == TC_NONE)
+	{
+		if ( GLimp_HaveExtension( "GL_S3_s3tc" ) )
+		{
+			if ( r_ext_compressed_textures->value )
+			{
+				glConfig.textureCompression = TC_S3TC;
+				ri.Printf( PRINT_ALL, "...using GL_S3_s3tc\n" );
+			}
+			else
+			{
+				ri.Printf( PRINT_ALL, "...ignoring GL_S3_s3tc\n" );
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...GL_S3_s3tc not found\n" );
+		}
+	}
+
+
+	// GL_EXT_texture_env_add
+	glConfig.textureEnvAddAvailable = qtrue; //qfalse;
+#if 0
+	if ( GLimp_HaveExtension( "EXT_texture_env_add" ) )
+	{
+		if ( r_ext_texture_env_add->integer )
+		{
+			glConfig.textureEnvAddAvailable = qtrue;
+			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_env_add\n" );
+		}
+		else
+		{
+			glConfig.textureEnvAddAvailable = qfalse;
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_env_add\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_texture_env_add not found\n" );
+	}
+#endif
+
+	// GL_ARB_multitexture
+	/*
+	qglMultiTexCoord2fARB = NULL;
+	qglActiveTextureARB = NULL;
+	qglClientActiveTextureARB = NULL;
+	*/
+	//if ( GLimp_HaveExtension( "GL_ARB_multitexture" ) )
+	{
+		if ( r_ext_multitexture->value )
+		{
+			qglMultiTexCoord2fARB = qglMultiTexCoord2f;
+			qglActiveTextureARB = qglActiveTexture;
+			qglClientActiveTextureARB = qglClientActiveTexture;
+
+			if ( qglActiveTextureARB )
+			{
+				GLint glint = 0;
+				qglGetIntegerv( GL_MAX_TEXTURE_UNITS, &glint );
+				glConfig.numTextureUnits = (int) glint;
+				if ( glConfig.numTextureUnits > 1 )
+				{
+					ri.Printf( PRINT_ALL, "...using GL_ARB_multitexture\n" );
+				}
+				else
+				{
+					qglMultiTexCoord2fARB = NULL;
+					qglActiveTextureARB = NULL;
+					qglClientActiveTextureARB = NULL;
+					ri.Printf( PRINT_ALL, "...not using GL_ARB_multitexture, < 2 texture units\n" );
+				}
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_ARB_multitexture\n" );
+		}
+	}
+#if 0
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_ARB_multitexture not found\n" );
+	}
+#endif
+
+#if 0
+	// GL_EXT_compiled_vertex_array
+	if ( GLimp_HaveExtension( "GL_EXT_compiled_vertex_array" ) )
+	{
+		if ( r_ext_compiled_vertex_array->value )
+		{
+			ri.Printf( PRINT_ALL, "...using GL_EXT_compiled_vertex_array\n" );
+			qglLockArraysEXT = ( void ( APIENTRY * )( GLint, GLint ) ) SDL_GL_GetProcAddress( "glLockArraysEXT" );
+			qglUnlockArraysEXT = ( void ( APIENTRY * )( void ) ) SDL_GL_GetProcAddress( "glUnlockArraysEXT" );
+			if (!qglLockArraysEXT || !qglUnlockArraysEXT)
+			{
+				ri.Error (ERR_FATAL, "bad getprocaddress");
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_compiled_vertex_array\n" );
+		}
+	}
+	else
+#endif
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_compiled_vertex_array not found\n" );
+	}
+
+	textureFilterAnisotropic = qfalse;
+#if 0
+	if ( GLimp_HaveExtension( "GL_EXT_texture_filter_anisotropic" ) )
+	{
+		if ( r_ext_texture_filter_anisotropic->integer ) {
+			qglGetIntegerv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, (GLint *)&maxAnisotropy );
+			if ( maxAnisotropy <= 0 ) {
+				ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not properly supported!\n" );
+				maxAnisotropy = 0;
+			}
+			else
+			{
+				ri.Printf( PRINT_ALL, "...using GL_EXT_texture_filter_anisotropic (max: %i)\n", maxAnisotropy );
+				textureFilterAnisotropic = qtrue;
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_filter_anisotropic\n" );
+		}
+	}
+	else
+#endif
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not found\n" );
+	}
+}
+
+void GLimp_Init(void)
+{
+	Screen *screen;
+	Visual *vis;
+	EGLint major, minor;
+
+	ri.Printf(PRINT_ALL, "Initializing OpenGL subsystem\n");
+
+	bzero(&glConfig, sizeof(glConfig));
+
+	if (!(dpy = XOpenDisplay(NULL))) {
+		printf("Error: couldn't open display \n");
+		assert(0);
+	}
+	screen = XDefaultScreenOfDisplay(dpy);
+	vis = DefaultVisual(dpy, DefaultScreen(dpy));
+
+	eglDisplay = eglGetDisplay((NativeDisplayType) dpy);
+	if (!eglInitialize(eglDisplay, &major, &minor))
+		GLimp_HandleError();
+
+	make_window(dpy, screen, eglDisplay, &eglSurface, &eglContext);
+
+	XMoveResizeWindow(dpy, win, 0, 0, WidthOfScreen(screen),
+			  HeightOfScreen(screen));
+
+	glConfig.isFullscreen = r_fullscreen->integer;
+	glConfig.vidWidth = WidthOfScreen(screen);
+	glConfig.vidHeight = HeightOfScreen(screen);
+	glConfig.windowAspect = (float)glConfig.vidWidth / glConfig.vidHeight;
+	// FIXME
+	//glConfig.colorBits = 0
+	//glConfig.stencilBits = 0;
+	//glConfig.depthBits = 0;
+	glConfig.textureCompression = TC_NONE;
+
+	// This values force the UI to disable driver selection
+	glConfig.driverType = GLDRV_ICD;
+	glConfig.hardwareType = GLHW_GENERIC;
+
+	Q_strncpyz(glConfig.vendor_string,
+		   (const char *)qglGetString(GL_VENDOR),
+		   sizeof(glConfig.vendor_string));
+	Q_strncpyz(glConfig.renderer_string,
+		   (const char *)qglGetString(GL_RENDERER),
+		   sizeof(glConfig.renderer_string));
+	Q_strncpyz(glConfig.version_string,
+		   (const char *)qglGetString(GL_VERSION),
+		   sizeof(glConfig.version_string));
+	Q_strncpyz(glConfig.extensions_string,
+		   (const char *)qglGetString(GL_EXTENSIONS),
+		   sizeof(glConfig.extensions_string));
+
+	qglLockArraysEXT = qglLockArrays;
+	qglUnlockArraysEXT = qglUnlockArrays;
+
+	GLimp_InitExtensions();
+
+	IN_Init( );
+
+	ri.Printf(PRINT_ALL, "------------------\n");
+}
+
+void GLimp_LogComment(char *comment)
+{
+	//fprintf(stderr, "%s: %s\n", __func__, comment);
+}
+
+void GLimp_EndFrame(void)
+{
+	if (Q_stricmp(r_drawBuffer->string, "GL_FRONT") != 0) {
+		eglSwapBuffers(eglDisplay, eglSurface);
+	}
+
+	XForceScreenSaver(dpy, ScreenSaverReset);
+
+}
+
+void GLimp_Shutdown(void)
+{
+	IN_Shutdown();
+
+	eglDestroyContext(eglDisplay, eglContext);
+	eglDestroySurface(eglDisplay, eglSurface);
+	eglMakeCurrent(eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+	eglTerminate(eglDisplay);
+
+	XDestroyWindow(dpy, win);
+	XCloseDisplay(dpy);
+}
+
+#if 1
+void qglArrayElement(GLint i)
+{
+}
+
+void qglCallList(GLuint list)
+{
+}
+
+void qglDrawBuffer(GLenum mode)
+{
+}
+
+void qglLockArrays(GLint i, GLsizei size)
+{
+}
+
+void qglUnlockArrays(void)
+{
+}
+#endif
+
+#if 1
+void GLimp_SetGamma(unsigned char red[256], unsigned char green[256],
+		    unsigned char blue[256])
+{
+}
+
+qboolean GLimp_SpawnRenderThread(void (*function) (void))
+{
+	return qfalse;
+}
+
+void GLimp_FrontEndSleep(void)
+{
+}
+
+void *GLimp_RendererSleep(void)
+{
+	return NULL;
+}
+
+void GLimp_RenderThreadWrapper(void *data)
+{
+}
+
+void GLimp_WakeRenderer(void *data)
+{
+}
+#endif
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./egl/egl_glimp.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/egl_glimp.h
--- ./egl/egl_glimp.h	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/egl_glimp.h	2012-05-25 14:17:11.973231571 +0300
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2009  Nokia Corporation.  All rights reserved.
+ */
+
+#ifndef __EGL_GLIMP_H__
+#define __EGL_GLIMP_H__
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/param.h>
+
+#include <X11/keysym.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+#include <GLES/egl.h>
+#include <GLES/gl.h>
+
+#include "egl_input.h"
+
+#ifndef GLAPI
+#define GLAPI extern
+#endif
+
+#ifndef GLAPIENTRY
+#define GLAPIENTRY
+#endif
+
+#ifndef APIENTRY
+#define APIENTRY GLAPIENTRY
+#endif
+
+/* "P" suffix to be used for a pointer to a function */
+#ifndef APIENTRYP
+#define APIENTRYP APIENTRY *
+#endif
+
+#ifndef GLAPIENTRYP
+#define GLAPIENTRYP GLAPIENTRY *
+#endif
+
+extern Display *dpy;
+extern Window win;
+extern EGLContext eglContext;
+extern EGLDisplay eglDisplay;
+extern EGLSurface eglSurface;
+int Sys_XTimeToSysTime(Time xtime);
+void GLimp_Init(void);
+void GLimp_LogComment(char *comment);
+void GLimp_EndFrame(void);
+void GLimp_Shutdown(void);
+void qglArrayElement(GLint i);
+void qglCallList(GLuint list);
+void qglDrawBuffer(GLenum mode);
+void qglLockArrays(GLint i, GLsizei size);
+void qglUnlockArrays(void);
+void GLimp_SetGamma(unsigned char red[256], unsigned char green[256],
+		    unsigned char blue[256]);
+qboolean GLimp_SpawnRenderThread(void (*function) (void));
+void GLimp_FrontEndSleep(void);
+void *GLimp_RendererSleep(void);
+void GLimp_RenderThreadWrapper(void *data);
+void GLimp_WakeRenderer(void *data);
+
+#define WINDOW_CLASS_NAME	"Quake III: Arena"
+
+#define KEY_MASK	(KeyPressMask | KeyReleaseMask)
+#define MOUSE_MASK	(ButtonPressMask | ButtonReleaseMask | PointerMotionMask | ButtonMotionMask)
+#define X_MASK		(KEY_MASK | MOUSE_MASK | VisibilityChangeMask | StructureNotifyMask)
+
+
+#endif
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./egl/egl_input.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/egl_input.c
--- ./egl/egl_input.c	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/egl_input.c	2012-05-25 14:17:11.973231571 +0300
@@ -0,0 +1,716 @@
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <X11/keysym.h>
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+#include <GLES/egl.h>
+#include <GLES/gl.h>
+
+#include "egl_glimp.h"
+#include "../client/client.h"
+#include "../renderer/tr_local.h"
+#include "../qcommon/q_shared.h"
+
+#define ACCEL_PATH	"/sys/class/i2c-adapter/i2c-3/3-001d/"
+#define PROXY_PATH	"/sys/devices/platform/gpio-switch/proximity/"
+
+static int mwx, mwy;
+static int mx = 0, my = 0;
+static qboolean mouse_active = qfalse;
+static qboolean mouse_avail = qfalse;
+
+cvar_t *in_nograb;
+static cvar_t *in_mouse;
+
+static cvar_t *accel_angle;
+static cvar_t *accel_debug;
+static cvar_t *accel_epsilon_x;
+/* Cache angle and its sin/cos */
+static int accel_angle_value;
+static float accel_sin, accel_cos;
+
+static cvar_t *accel_epsilon_y;
+static cvar_t *accel_fudge;
+static cvar_t *accel_jump;
+
+static int mouse_accel_denominator;
+static int mouse_accel_numerator;
+static int mouse_threshold;
+
+static int win_x, win_y;
+
+/*****************************************************************************
+** KEYBOARD
+** NOTE TTimo the keyboard handling is done with KeySyms
+**   that means relying on the keyboard mapping provided by X
+**   in-game it would probably be better to use KeyCode (i.e. hardware key codes)
+**   you would still need the KeySyms in some cases, such as for the console and all entry textboxes
+**     (cause there's nothing worse than a qwerty mapping on a french keyboard)
+**
+** you can turn on some debugging and verbose of the keyboard code with #define KBD_DBG
+******************************************************************************/
+
+#define KBD_DBG
+
+static char *XLateKey(XKeyEvent * ev, int *key)
+{
+	static char buf[64];
+	KeySym keysym;
+	int XLookupRet;
+
+	*key = 0;
+
+	XLookupRet = XLookupString(ev, buf, sizeof buf, &keysym, 0);
+#ifdef KBD_DBG
+	ri.Printf(PRINT_ALL, "XLookupString ret: %d buf: %s keysym: %x\n",
+		  XLookupRet, buf, keysym);
+#endif
+
+	switch (keysym) {
+	case XK_KP_Page_Up:
+	case XK_KP_9:
+		*key = K_KP_PGUP;
+		break;
+	case XK_Page_Up:
+		*key = K_PGUP;
+		break;
+
+	case XK_KP_Page_Down:
+	case XK_KP_3:
+		*key = K_KP_PGDN;
+		break;
+	case XK_Page_Down:
+		*key = K_PGDN;
+		break;
+
+	case XK_KP_Home:
+		*key = K_KP_HOME;
+		break;
+	case XK_KP_7:
+		*key = K_KP_HOME;
+		break;
+	case XK_Home:
+		*key = K_HOME;
+		break;
+
+	case XK_KP_End:
+	case XK_KP_1:
+		*key = K_KP_END;
+		break;
+	case XK_End:
+		*key = K_END;
+		break;
+
+	case XK_KP_Left:
+		*key = K_KP_LEFTARROW;
+		break;
+	case XK_KP_4:
+		*key = K_KP_LEFTARROW;
+		break;
+	case XK_Left:
+		*key = K_LEFTARROW;
+		break;
+
+	case XK_KP_Right:
+		*key = K_KP_RIGHTARROW;
+		break;
+	case XK_KP_6:
+		*key = K_KP_RIGHTARROW;
+		break;
+	case XK_Right:
+		*key = K_RIGHTARROW;
+		break;
+
+	case XK_KP_Down:
+	case XK_KP_2:
+		*key = K_KP_DOWNARROW;
+		break;
+	case XK_Down:
+		*key = K_DOWNARROW;
+		break;
+
+	case XK_KP_Up:
+	case XK_KP_8:
+		*key = K_KP_UPARROW;
+		break;
+	case XK_Up:
+		*key = K_UPARROW;
+		break;
+
+	case XK_Escape:
+	case 0x3d:			/* N900: (Fn +) = */
+		*key = K_ESCAPE;
+		break;
+
+	case XK_KP_Enter:
+		*key = K_KP_ENTER;
+		break;
+	case XK_Return:
+		*key = K_ENTER;
+		break;
+
+	case XK_Tab:
+		*key = K_TAB;
+		break;
+
+	case XK_F1:
+		*key = K_F1;
+		break;
+
+	case XK_F2:
+		*key = K_F2;
+		break;
+
+	case XK_F3:
+		*key = K_F3;
+		break;
+
+	case XK_F4:
+		*key = K_F4;
+		break;
+
+	case XK_F5:
+		*key = K_F5;
+		break;
+
+	case XK_F6:
+		*key = K_F6;
+		break;
+
+	case XK_F7:
+		*key = K_F7;
+		break;
+
+	case XK_F8:
+		*key = K_F8;
+		break;
+
+	case XK_F9:
+		*key = K_F9;
+		break;
+
+	case XK_F10:
+		*key = K_F10;
+		break;
+
+	case XK_F11:
+		*key = K_F11;
+		break;
+
+	case XK_F12:
+		*key = K_F12;
+		break;
+
+		// bk001206 - from Ryan's Fakk2 
+		//case XK_BackSpace: *key = 8; break; // ctrl-h
+	case XK_BackSpace:
+		*key = K_BACKSPACE;
+		break;		// ctrl-h
+
+	case XK_KP_Delete:
+	case XK_KP_Decimal:
+		*key = K_KP_DEL;
+		break;
+	case XK_Delete:
+		*key = K_DEL;
+		break;
+
+	case XK_Pause:
+		*key = K_PAUSE;
+		break;
+
+	case XK_Shift_L:
+	case XK_Shift_R:
+		*key = K_SHIFT;
+		break;
+
+	case XK_Execute:
+	case XK_Control_L:
+	case XK_Control_R:
+		*key = K_CTRL;
+		break;
+
+	case XK_Alt_L:
+	case XK_Meta_L:
+	case XK_Alt_R:
+	case XK_Meta_R:
+		*key = K_ALT;
+		break;
+
+	case XK_KP_Begin:
+		*key = K_KP_5;
+		break;
+
+	case XK_Insert:
+		*key = K_INS;
+		break;
+	case XK_KP_Insert:
+	case XK_KP_0:
+		*key = K_KP_INS;
+		break;
+
+	case XK_KP_Multiply:
+		*key = '*';
+		break;
+	case XK_KP_Add:
+		*key = K_KP_PLUS;
+		break;
+	case XK_KP_Subtract:
+		*key = K_KP_MINUS;
+		break;
+	case XK_KP_Divide:
+		*key = K_KP_SLASH;
+		break;
+
+		// bk001130 - from cvs1.17 (mkv)
+	case XK_exclam:
+		*key = '1';
+		break;
+	case XK_at:
+		*key = '2';
+		break;
+	case XK_numbersign:
+		*key = '3';
+		break;
+	case XK_dollar:
+		*key = '4';
+		break;
+	case XK_percent:
+		*key = '5';
+		break;
+	case XK_asciicircum:
+		*key = '6';
+		break;
+	case XK_ampersand:
+		*key = '7';
+		break;
+	case XK_asterisk:
+		*key = '8';
+		break;
+	case XK_parenleft:
+		*key = '9';
+		break;
+	case XK_parenright:
+		*key = '0';
+		break;
+
+	case XK_twosuperior:
+	case 0xff20:			/* N900: Fn + Sym/Ctrl */
+		*key = K_CONSOLE;
+		*buf = '\0';
+		break;
+
+		// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=472
+	case XK_space:
+	case XK_KP_Space:
+		*key = K_SPACE;
+		break;
+
+	default:
+		if (XLookupRet == 0) {
+			if (com_developer->value) {
+				ri.Printf(PRINT_ALL,
+					  "Warning: XLookupString failed on KeySym %d\n",
+					  keysym);
+			}
+			return NULL;
+		} else {
+			// XK_* tests failed, but XLookupString got a buffer, so let's try it
+			*key = *(unsigned char *)buf;
+			if (*key >= 'A' && *key <= 'Z')
+				*key = *key - 'A' + 'a';
+			// if ctrl is pressed, the keys are not between 'A' and 'Z', for instance ctrl-z == 26 ^Z ^C etc.
+			// see https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=19
+			else if (*key >= 1 && *key <= 26)
+				*key = *key + 'a' - 1;
+		}
+		break;
+	}
+
+	return buf;
+}
+
+static void Proximity_HandleEvents(void)
+{
+	char buf[16];
+	FILE *fp;
+	int t;
+	static qboolean oldState = qfalse, state = qfalse;
+
+	fp = fopen(PROXY_PATH "/state", "r");
+	if (!fp)
+		return;
+	fgets(buf, sizeof(buf), fp);
+	fclose(fp);
+
+	if (Q_stricmp(buf, "closed\n") == 0) {
+		state = qtrue;
+	} else {
+		state = qfalse;
+	}
+
+	if (state != oldState) {
+		t = Sys_Milliseconds();
+		Com_QueueEvent(t, SE_KEY, K_MOUSE1, state, 0, NULL);
+		oldState = state;
+	}
+}
+
+static void Accelerometer_WriteFudge(void)
+{
+	FILE *fp;
+
+	if (!accel_fudge)
+		accel_fudge = Cvar_Get("accel_fudge", "3", CVAR_ARCHIVE);
+	if (access(ACCEL_PATH "/fudge", W_OK) < 0)
+		return;
+	if (!(fp = fopen(ACCEL_PATH "/fudge", "w")))
+		return;
+
+	fprintf(fp, "%d\n", accel_fudge->integer);
+
+	fclose(fp);
+}
+
+static void Accelerometer_ReadCoords(int *x, int *y, int *z)
+{
+	char buf[16];
+	FILE *fp;
+	static qboolean fudge = qfalse;
+
+	if (!fudge) {
+		Accelerometer_WriteFudge();
+		fudge = qtrue;
+	}
+
+	fp = fopen(ACCEL_PATH "/coord", "r");
+	if (!fp)
+		return;
+
+	fgets(buf, sizeof(buf), fp);
+	sscanf(buf, "%d %d %d\n", x, y, z);
+
+	if (accel_debug->integer) {
+		Com_DPrintf("Accelerometer_ReadCoords: %d %d %d\n", *x, *y, *z);
+	}
+
+	fclose(fp);
+}
+
+static void Accelerometer_HandleEvents(void)
+{
+	int dx = 0, dy = 0;
+	int t, tmp;
+	int x, y, z;
+	static int jumpTime = 0;
+
+	t = Sys_Milliseconds();
+
+	if (!accel_angle) {
+		accel_angle = Cvar_Get("accel_angle", "45", CVAR_ARCHIVE);
+	}
+	if (!accel_debug) {
+		accel_debug = Cvar_Get("accel_debug", "0", CVAR_ARCHIVE);
+	}
+	if (!accel_jump) {
+		accel_jump = Cvar_Get("accel_jump", "-1300", CVAR_ARCHIVE);
+	}
+	if (!accel_epsilon_x) {
+		accel_epsilon_x =
+		    Cvar_Get("accel_epsilon_x", "100", CVAR_ARCHIVE);
+	}
+	if (!accel_epsilon_y) {
+		accel_epsilon_y =
+		    Cvar_Get("accel_epsilon_y", "100", CVAR_ARCHIVE);
+	}
+
+	Accelerometer_ReadCoords(&x, &y, &z);
+
+	/* only update sin and cos if the cvar's changed */
+	tmp = accel_angle->value;
+	if(tmp != accel_angle_value) {
+		/* what happened to sincosf()? */
+		accel_sin = sin(DEG2RAD(tmp));
+		accel_cos = cos(DEG2RAD(tmp));
+		accel_angle_value = tmp;
+	}
+	tmp = y * accel_cos - z * accel_sin;
+	z = z * accel_cos + y * accel_sin;
+	y = tmp;
+
+	if (accel_debug->integer) {
+		Com_DPrintf("Accelerometer_HandleEvents: y = %d\n", y);
+	}
+
+	if (accel_jump->value) {
+		float mag = sqrtf(y*y+z*z);
+		// HACK - change the sign of jump to be +ve not -ve
+		// HACK - z<0 means that lots of jerks will look like jumps
+		//        change it to < -500 or < accel_jump->value/2
+		int looks_like_a_jump = (mag > -accel_jump->value) && (z < 0);
+		if (!jumpTime && looks_like_a_jump) {
+			Com_QueueEvent(t, SE_KEY, K_SPACE, qtrue, 0, NULL);
+			jumpTime = t;
+		} else if (jumpTime && !looks_like_a_jump) {
+			Com_QueueEvent(t, SE_KEY, K_SPACE, qfalse, 0, NULL);
+			jumpTime = 0;
+		}
+	}
+
+	if (x > accel_epsilon_x->integer)
+		dx = -(x - accel_epsilon_x->integer);
+	else if (x < -accel_epsilon_x->integer)
+		dx = -(x + accel_epsilon_x->integer);
+
+	if (y > accel_epsilon_y->integer)
+		dy = -(y - accel_epsilon_y->integer);
+	else if (y < -accel_epsilon_y->integer)
+		dy = -(y + accel_epsilon_y->integer);
+
+	dx *= cl_sensitivity->value;
+	dy *= cl_sensitivity->value;
+
+	Com_QueueEvent(t, SE_ACCEL, dx, dy, 0, NULL);
+}
+
+static qboolean motionPressed = qfalse;
+
+qboolean IN_MotionPressed(void)
+{
+	return motionPressed;
+}
+
+static void HandleEvents(void)
+{
+	int key;
+	XEvent event;
+	char *p;
+	static int dx = 0, dy = 0;
+	int t = 0;		// default to 0 in case we don't set
+
+	if (!dpy)
+		return;
+
+	while (XPending(dpy)) {
+		XNextEvent(dpy, &event);
+		switch (event.type) {
+		case KeyPress:
+			t = Sys_XTimeToSysTime(event.xkey.time);
+			p = XLateKey(&event.xkey, &key);
+			if (key) {
+				Com_QueueEvent(t, SE_KEY, key, qtrue, 0, NULL);
+			}
+			if (p) {
+				while (*p) {
+					Com_QueueEvent(t, SE_CHAR, *p++, 0, 0,
+						       NULL);
+				}
+			}
+			break;
+
+		case KeyRelease:
+			t = Sys_XTimeToSysTime(event.xkey.time);
+#if 0
+			// bk001206 - handle key repeat w/o XAutRepatOn/Off
+			//            also: not done if console/menu is active.
+			// From Ryan's Fakk2.
+			// see game/q_shared.h, KEYCATCH_* . 0 == in 3d game.  
+			if (cls.keyCatchers == 0) {	// FIXME: KEYCATCH_NONE
+				if (repeated_press(&event) == qtrue)
+					continue;
+			}	// if
+#endif
+			XLateKey(&event.xkey, &key);
+
+			Com_QueueEvent(t, SE_KEY, key, qfalse, 0, NULL);
+			break;
+
+		case MotionNotify:
+			t = Sys_XTimeToSysTime(event.xkey.time);
+			dx = event.xmotion.x;
+			dy = event.xmotion.y;
+			break;
+
+		case ButtonPress:
+		case ButtonRelease:
+			t = Sys_XTimeToSysTime(event.xkey.time);
+			motionPressed = (qboolean) (event.type == ButtonPress);
+			if (Key_GetCatcher() & (KEYCATCH_CGAME | KEYCATCH_UI)) {
+				Com_QueueEvent(t, SE_KEY, K_MOUSE1,
+					       motionPressed, 0, NULL);
+			}
+			break;
+
+		case CreateNotify:
+			win_x = event.xcreatewindow.x;
+			win_y = event.xcreatewindow.y;
+			break;
+
+		case ConfigureNotify:
+			win_x = event.xconfigure.x;
+			win_y = event.xconfigure.y;
+			break;
+		}
+	}
+
+	if (motionPressed) {
+		Com_QueueEvent(t, SE_MOUSE, dx, dy, 0, NULL);
+	}
+
+	Proximity_HandleEvents();
+
+	Accelerometer_HandleEvents();
+}
+
+static Cursor CreateNullCursor(Display * display, Window root)
+{
+	Pixmap cursormask;
+	XGCValues xgc;
+	GC gc;
+	XColor dummycolour;
+	Cursor cursor;
+
+	cursormask = XCreatePixmap(display, root, 1, 1, 1 /*depth */ );
+	xgc.function = GXclear;
+	gc = XCreateGC(display, cursormask, GCFunction, &xgc);
+	XFillRectangle(display, cursormask, gc, 0, 0, 1, 1);
+	dummycolour.pixel = 0;
+	dummycolour.red = 0;
+	dummycolour.flags = 0x4;
+	cursor =
+	    XCreatePixmapCursor(display, cursormask, cursormask, &dummycolour,
+				&dummycolour, 0, 0);
+	XFreePixmap(display, cursormask);
+	XFreeGC(display, gc);
+	return cursor;
+}
+
+static void hildon_set_non_compositing(void)
+{
+	Atom atom;
+	int one = 1;
+
+	atom = XInternAtom(dpy, "_HILDON_NON_COMPOSITED_WINDOW", False);
+	XChangeProperty(dpy, win, atom, XA_INTEGER, 32, PropModeReplace,
+			(unsigned char *)&one, 1);
+}
+
+static void install_grabs(void)
+{
+	XSync(dpy, False);
+
+	hildon_set_non_compositing();
+
+	XDefineCursor(dpy, win, CreateNullCursor(dpy, win));
+
+	XGrabPointer(dpy, win, False, MOUSE_MASK, GrabModeAsync, GrabModeAsync,
+		     win, None, CurrentTime);
+
+	XGetPointerControl(dpy, &mouse_accel_numerator,
+			   &mouse_accel_denominator, &mouse_threshold);
+
+	XChangePointerControl(dpy, True, True, 1, 1, 0);
+
+	XSync(dpy, False);
+
+	mwx = glConfig.vidWidth / 2;
+	mwy = glConfig.vidHeight / 2;
+	mx = my = 0;
+
+	XGrabKeyboard(dpy, win, False, GrabModeAsync, GrabModeAsync,
+		      CurrentTime);
+
+	XSync(dpy, False);
+}
+
+static void uninstall_grabs(void)
+{
+	XChangePointerControl(dpy, qtrue, qtrue, mouse_accel_numerator,
+			      mouse_accel_denominator, mouse_threshold);
+
+	XUngrabPointer(dpy, CurrentTime);
+	XUngrabKeyboard(dpy, CurrentTime);
+
+	XUndefineCursor(dpy, win);
+}
+
+void IN_ActivateMouse(void)
+{
+	if (!mouse_avail || !dpy || !win)
+		return;
+
+	if (!mouse_active) {
+		if (!in_nograb->value)
+			install_grabs();
+		mouse_active = qtrue;
+	}
+}
+
+void IN_DeactivateMouse(void)
+{
+	if (!mouse_avail || !dpy || !win)
+		return;
+
+	if (mouse_active) {
+		if (!in_nograb->value)
+			uninstall_grabs();
+		mouse_active = qfalse;
+	}
+}
+
+void IN_Frame(void)
+{
+	qboolean loading;
+
+	HandleEvents();
+
+	// If not DISCONNECTED (main menu) or ACTIVE (in game), we're loading
+	loading = !!(cls.state != CA_DISCONNECTED && cls.state != CA_ACTIVE);
+
+	if (!r_fullscreen->integer && (Key_GetCatcher() & KEYCATCH_CONSOLE)) {
+		// Console is down in windowed mode
+		IN_DeactivateMouse();
+	} else if (!r_fullscreen->integer && loading) {
+		// Loading in windowed mode
+		IN_DeactivateMouse();
+	} else
+		IN_ActivateMouse();
+}
+
+void IN_Init(void)
+{
+	Com_DPrintf("\n------- Input Initialization -------\n");
+
+	// mouse variables
+	in_mouse = Cvar_Get("in_mouse", "1", CVAR_ARCHIVE);
+	in_nograb = Cvar_Get("in_nograb", "0", CVAR_ARCHIVE);
+
+	if (in_mouse->value) {
+		mouse_avail = qtrue;
+		IN_ActivateMouse();
+	} else {
+		IN_DeactivateMouse();
+		mouse_avail = qfalse;
+	}
+
+	Com_DPrintf("------------------------------------\n");
+}
+
+void IN_Shutdown(void)
+{
+	IN_DeactivateMouse();
+	mouse_avail = qfalse;
+}
+
+void IN_Restart(void)
+{
+	IN_Init();
+}
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./egl/egl_input.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/egl_input.h
--- ./egl/egl_input.h	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/egl_input.h	2012-05-25 14:17:11.973231571 +0300
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2009  Nokia Corporation.  All rights reserved.
+ */
+
+#ifndef __EGL_INPUT_H__
+#define __EGL_INPUT_H__
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/param.h>
+
+#include <X11/keysym.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+#include <GLES/egl.h>
+#include <GLES/gl.h>
+
+#include "../qcommon/q_shared.h"
+
+extern cvar_t *in_nograb;
+qboolean IN_MotionPressed(void);
+void IN_ActivateMouse(void);
+void IN_DeactivateMouse(void);
+void IN_Frame(void);
+void IN_Init(void);
+void IN_Shutdown(void);
+void IN_Restart(void);
+
+#endif
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./egl/GenerateQGL.pl /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/GenerateQGL.pl
--- ./egl/GenerateQGL.pl	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/GenerateQGL.pl	2012-05-25 14:17:11.973231571 +0300
@@ -0,0 +1,147 @@
+#!/usr/bin/perl
+
+open(INPUT_FILE, ">/tmp/input-$$.h") || die "$!";
+print INPUT_FILE "#import <GLES/gl.h>\n";
+close INPUT_FILE;
+open(CPP, "/usr/bin/cpp /tmp/input-$$.h|") || die "$!";
+
+print "/**** This file is autogenerated.  Run GenerateQGL.pl to update it ****/\n\n";
+
+print "#ifdef QGL_LOG_GL_CALLS\n";
+print "extern unsigned int QGLLogGLCalls;\n";
+print "extern FILE *QGLDebugFile(void);\n";
+print "#endif\n\n";
+
+print "extern void QGLCheckError(const char *message);\n";
+print "extern unsigned int QGLBeginStarted;\n\n";
+print "// This has to be done to avoid infinite recursion between our glGetError wrapper and QGLCheckError()\n";
+print "static inline GLenum _glGetError(void) {\n";
+print "    return glGetError();\n";
+print "}\n\n";
+
+@functionNames = ();
+
+while (<CPP>) {
+    chop;
+    /^extern/ || next;
+    s/extern //;
+    print "// $_\n";
+
+    # This approach is necessary to deal with glGetString whos type isn't a single word
+    ($type, $rest) = m/(.+)\s+(gl.*)/;
+#    print "type='$type'\n";
+#    print "rest='$rest'\n";
+
+    ($name, $argString) = ($rest =~ m/(\w+).*\s*\((.*)\)/);
+	next if ($name eq "glColor4f");
+    $isVoid = ($type =~ m/void/);
+    push(@functionNames, $name);
+
+#    print "name=$name\n";
+#    print "argString=$argString\n";
+#    print "argCount=$#args\n";
+
+    # Parse the argument list into two arrays, one of types and one of argument names
+    if ($argString =~ m/^void$/) {
+        @args = ();
+    } else {
+        @args = split(",", $argString);
+    }
+    @argTypes = ();
+    @argNames = ();
+    for $arg (@args) {
+        ($argType, $argName) = ($arg =~ m/(.*[ \*])([_a-zA-Z0-9]+)/);
+        $argType =~ s/^ *//;
+        $argType =~ s/ *$//;
+
+        push(@argTypes, $argType);
+        push(@argNames, $argName);
+#        print "argType='$argType'\n";
+#        print "argName='$argName'\n";
+    }
+
+
+    print "static inline $type q$name($argString)\n";
+    print "{\n";
+
+    if (! $isVoid) {
+        print "    $type returnValue;\n";
+    }
+
+    print "#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)\n";
+    print "    if (QGLLogGLCalls)\n";
+    print "        fprintf(QGLDebugFile(), \"$name(";
+
+    if ($#argTypes >= 0) {
+        for ($i = 0; $i <= $#argTypes; $i++) {
+            $argType = $argTypes[$i];
+            $argName = $argNames[$i];
+            $_ = $argType;
+            if (/^GLenum$/ || /^GLuint$/ || /^GLbitfield$/) {
+                print "$argName=%lu";
+            } elsif (/^GLsizei$/ || /^GLint$/ || /^GLsizeiptr$/ || /^GLintptr$/ || /^GLfixed$/ || /^GLclampx$/) {
+                print "$argName=%ld";
+            } elsif (/^GLfloat$/ || /^GLdouble$/ || /^GLclampf$/ || /^GLclampd$/) {
+                print "$argName=%f";
+            } elsif (/^GLbyte$/) {
+                print "$argName=%d";
+            } elsif (/^GLubyte$/) {
+                print "$argName=%u";
+            } elsif (/^GLshort$/) {
+                print "$argName=%d";
+            } elsif (/^GLushort$/) {
+                print "$argName=%u";
+            } elsif (/^GLboolean$/) {
+                print "$argName=%u";
+            } elsif (/\*$/) {
+                # TJW -- Later we should look at the count specified in the function name, look at the basic type and print out an array.  Or we could just special case them...
+                print "$argName=%p";
+            } else {
+                print STDERR "Unknown type '$argType'\n";
+                exit(1);
+            }
+
+            print ", " if ($i != $#argTypes);
+        }
+    } else {
+        print "void";
+    }
+
+    print ")\\n\"";
+    print ", " if $#argTypes >= 0;
+    print join(", ", @argNames);
+    print ");\n";
+    print "#endif\n";
+
+    if (! $isVoid) {
+        print "    returnValue = ";
+    } else {
+        print "    ";
+    }
+    print "$name(" . join(", ", @argNames) . ");\n";
+
+    print "#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)\n";
+    if ($name eq "glBegin") {
+        print "    QGLBeginStarted++;\n";
+    }
+    if ($name eq "glEnd") {
+        print "    QGLBeginStarted--;\n";
+    }
+    print "    if (!QGLBeginStarted)\n";
+    print "        QGLCheckError(\"$name\");\n";
+    print "#endif\n";
+
+    if (! $isVoid) {
+        print "    return returnValue;\n";
+    }
+    
+    print "}\n\n";
+}
+
+
+print "// Prevent calls to the 'normal' GL functions\n";
+for $name (@functionNames) {
+    print "#define $name CALL_THE_QGL_VERSION_OF_$name\n";
+}
+
+
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./egl/qgl.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/qgl.h
--- ./egl/qgl.h	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/qgl.h	2012-05-25 14:17:11.973231571 +0300
@@ -0,0 +1,2187 @@
+/**** This file is autogenerated.  Run GenerateQGL.pl to update it ****/
+
+#ifdef QGL_LOG_GL_CALLS
+extern unsigned int QGLLogGLCalls;
+extern FILE *QGLDebugFile(void);
+#endif
+
+extern void QGLCheckError(const char *message);
+extern unsigned int QGLBeginStarted;
+
+// This has to be done to avoid infinite recursion between our glGetError wrapper and QGLCheckError()
+static inline GLenum _glGetError(void) {
+    return glGetError();
+}
+
+// void glAlphaFunc (GLenum func, GLclampf ref);
+static inline void qglAlphaFunc(GLenum func, GLclampf ref)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glAlphaFunc(func=%lu, ref=%f)\n", func, ref);
+#endif
+    glAlphaFunc(func, ref);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glAlphaFunc");
+#endif
+}
+
+// void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+static inline void qglClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClearColor(red=%f, green=%f, blue=%f, alpha=%f)\n", red, green, blue, alpha);
+#endif
+    glClearColor(red, green, blue, alpha);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClearColor");
+#endif
+}
+
+// void glClearDepthf (GLclampf depth);
+static inline void qglClearDepthf(GLclampf depth)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClearDepthf(depth=%f)\n", depth);
+#endif
+    glClearDepthf(depth);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClearDepthf");
+#endif
+}
+
+// void glClipPlanef (GLenum plane, const GLfloat *equation);
+static inline void qglClipPlanef(GLenum plane, const GLfloat *equation)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClipPlanef(plane=%lu, equation=%p)\n", plane, equation);
+#endif
+    glClipPlanef(plane, equation);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClipPlanef");
+#endif
+}
+
+// void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
+// void glDepthRangef (GLclampf zNear, GLclampf zFar);
+static inline void qglDepthRangef(GLclampf zNear, GLclampf zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDepthRangef(zNear=%f, zFar=%f)\n", zNear, zFar);
+#endif
+    glDepthRangef(zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDepthRangef");
+#endif
+}
+
+// void glFogf (GLenum pname, GLfloat param);
+static inline void qglFogf(GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFogf(pname=%lu, param=%f)\n", pname, param);
+#endif
+    glFogf(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFogf");
+#endif
+}
+
+// void glFogfv (GLenum pname, const GLfloat *params);
+static inline void qglFogfv(GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFogfv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glFogfv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFogfv");
+#endif
+}
+
+// void glFrustumf (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+static inline void qglFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFrustumf(left=%f, right=%f, bottom=%f, top=%f, zNear=%f, zFar=%f)\n", left, right, bottom, top, zNear, zFar);
+#endif
+    glFrustumf(left, right, bottom, top, zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFrustumf");
+#endif
+}
+
+// void glGetClipPlanef (GLenum pname, GLfloat eqn[4]);
+static inline void qglGetClipPlanef(GLenum pname, GLfloat eqn[4])
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetClipPlanef(pname=%lu, eqn=%f)\n", pname, eqn);
+#endif
+    glGetClipPlanef(pname, eqn);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetClipPlanef");
+#endif
+}
+
+// void glGetFloatv (GLenum pname, GLfloat *params);
+static inline void qglGetFloatv(GLenum pname, GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetFloatv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glGetFloatv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetFloatv");
+#endif
+}
+
+// void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
+static inline void qglGetLightfv(GLenum light, GLenum pname, GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetLightfv(light=%lu, pname=%lu, params=%p)\n", light, pname, params);
+#endif
+    glGetLightfv(light, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetLightfv");
+#endif
+}
+
+// void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
+static inline void qglGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetMaterialfv(face=%lu, pname=%lu, params=%p)\n", face, pname, params);
+#endif
+    glGetMaterialfv(face, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetMaterialfv");
+#endif
+}
+
+// void glGetTexEnvfv (GLenum env, GLenum pname, GLfloat *params);
+static inline void qglGetTexEnvfv(GLenum env, GLenum pname, GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexEnvfv(env=%lu, pname=%lu, params=%p)\n", env, pname, params);
+#endif
+    glGetTexEnvfv(env, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexEnvfv");
+#endif
+}
+
+// void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
+static inline void qglGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexParameterfv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glGetTexParameterfv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexParameterfv");
+#endif
+}
+
+// void glLightModelf (GLenum pname, GLfloat param);
+static inline void qglLightModelf(GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightModelf(pname=%lu, param=%f)\n", pname, param);
+#endif
+    glLightModelf(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightModelf");
+#endif
+}
+
+// void glLightModelfv (GLenum pname, const GLfloat *params);
+static inline void qglLightModelfv(GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightModelfv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glLightModelfv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightModelfv");
+#endif
+}
+
+// void glLightf (GLenum light, GLenum pname, GLfloat param);
+static inline void qglLightf(GLenum light, GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightf(light=%lu, pname=%lu, param=%f)\n", light, pname, param);
+#endif
+    glLightf(light, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightf");
+#endif
+}
+
+// void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
+static inline void qglLightfv(GLenum light, GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightfv(light=%lu, pname=%lu, params=%p)\n", light, pname, params);
+#endif
+    glLightfv(light, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightfv");
+#endif
+}
+
+// void glLineWidth (GLfloat width);
+static inline void qglLineWidth(GLfloat width)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLineWidth(width=%f)\n", width);
+#endif
+    glLineWidth(width);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLineWidth");
+#endif
+}
+
+// void glLoadMatrixf (const GLfloat *m);
+static inline void qglLoadMatrixf(const GLfloat *m)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLoadMatrixf(m=%p)\n", m);
+#endif
+    glLoadMatrixf(m);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLoadMatrixf");
+#endif
+}
+
+// void glMaterialf (GLenum face, GLenum pname, GLfloat param);
+static inline void qglMaterialf(GLenum face, GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMaterialf(face=%lu, pname=%lu, param=%f)\n", face, pname, param);
+#endif
+    glMaterialf(face, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMaterialf");
+#endif
+}
+
+// void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
+static inline void qglMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMaterialfv(face=%lu, pname=%lu, params=%p)\n", face, pname, params);
+#endif
+    glMaterialfv(face, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMaterialfv");
+#endif
+}
+
+// void glMultMatrixf (const GLfloat *m);
+static inline void qglMultMatrixf(const GLfloat *m)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMultMatrixf(m=%p)\n", m);
+#endif
+    glMultMatrixf(m);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMultMatrixf");
+#endif
+}
+
+// void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+static inline void qglMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMultiTexCoord4f(target=%lu, s=%f, t=%f, r=%f, q=%f)\n", target, s, t, r, q);
+#endif
+    glMultiTexCoord4f(target, s, t, r, q);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMultiTexCoord4f");
+#endif
+}
+
+// void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
+static inline void qglNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glNormal3f(nx=%f, ny=%f, nz=%f)\n", nx, ny, nz);
+#endif
+    glNormal3f(nx, ny, nz);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glNormal3f");
+#endif
+}
+
+// void glOrthof (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
+static inline void qglOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glOrthof(left=%f, right=%f, bottom=%f, top=%f, zNear=%f, zFar=%f)\n", left, right, bottom, top, zNear, zFar);
+#endif
+    glOrthof(left, right, bottom, top, zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glOrthof");
+#endif
+}
+
+// void glPointParameterf (GLenum pname, GLfloat param);
+static inline void qglPointParameterf(GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointParameterf(pname=%lu, param=%f)\n", pname, param);
+#endif
+    glPointParameterf(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointParameterf");
+#endif
+}
+
+// void glPointParameterfv (GLenum pname, const GLfloat *params);
+static inline void qglPointParameterfv(GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointParameterfv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glPointParameterfv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointParameterfv");
+#endif
+}
+
+// void glPointSize (GLfloat size);
+static inline void qglPointSize(GLfloat size)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointSize(size=%f)\n", size);
+#endif
+    glPointSize(size);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointSize");
+#endif
+}
+
+// void glPolygonOffset (GLfloat factor, GLfloat units);
+static inline void qglPolygonOffset(GLfloat factor, GLfloat units)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPolygonOffset(factor=%f, units=%f)\n", factor, units);
+#endif
+    glPolygonOffset(factor, units);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPolygonOffset");
+#endif
+}
+
+// void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
+static inline void qglRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glRotatef(angle=%f, x=%f, y=%f, z=%f)\n", angle, x, y, z);
+#endif
+    glRotatef(angle, x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glRotatef");
+#endif
+}
+
+// void glScalef (GLfloat x, GLfloat y, GLfloat z);
+static inline void qglScalef(GLfloat x, GLfloat y, GLfloat z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glScalef(x=%f, y=%f, z=%f)\n", x, y, z);
+#endif
+    glScalef(x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glScalef");
+#endif
+}
+
+// void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
+static inline void qglTexEnvf(GLenum target, GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnvf(target=%lu, pname=%lu, param=%f)\n", target, pname, param);
+#endif
+    glTexEnvf(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnvf");
+#endif
+}
+
+// void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
+static inline void qglTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnvfv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexEnvfv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnvfv");
+#endif
+}
+
+// void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
+static inline void qglTexParameterf(GLenum target, GLenum pname, GLfloat param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameterf(target=%lu, pname=%lu, param=%f)\n", target, pname, param);
+#endif
+    glTexParameterf(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameterf");
+#endif
+}
+
+// void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
+static inline void qglTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameterfv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexParameterfv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameterfv");
+#endif
+}
+
+// void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
+static inline void qglTranslatef(GLfloat x, GLfloat y, GLfloat z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTranslatef(x=%f, y=%f, z=%f)\n", x, y, z);
+#endif
+    glTranslatef(x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTranslatef");
+#endif
+}
+
+// void glActiveTexture (GLenum texture);
+static inline void qglActiveTexture(GLenum texture)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glActiveTexture(texture=%lu)\n", texture);
+#endif
+    glActiveTexture(texture);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glActiveTexture");
+#endif
+}
+
+// void glAlphaFuncx (GLenum func, GLclampx ref);
+static inline void qglAlphaFuncx(GLenum func, GLclampx ref)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glAlphaFuncx(func=%lu, ref=%ld)\n", func, ref);
+#endif
+    glAlphaFuncx(func, ref);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glAlphaFuncx");
+#endif
+}
+
+// void glBindBuffer (GLenum target, GLuint buffer);
+static inline void qglBindBuffer(GLenum target, GLuint buffer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glBindBuffer(target=%lu, buffer=%lu)\n", target, buffer);
+#endif
+    glBindBuffer(target, buffer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glBindBuffer");
+#endif
+}
+
+// void glBindTexture (GLenum target, GLuint texture);
+static inline void qglBindTexture(GLenum target, GLuint texture)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glBindTexture(target=%lu, texture=%lu)\n", target, texture);
+#endif
+    glBindTexture(target, texture);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glBindTexture");
+#endif
+}
+
+// void glBlendFunc (GLenum sfactor, GLenum dfactor);
+static inline void qglBlendFunc(GLenum sfactor, GLenum dfactor)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glBlendFunc(sfactor=%lu, dfactor=%lu)\n", sfactor, dfactor);
+#endif
+    glBlendFunc(sfactor, dfactor);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glBlendFunc");
+#endif
+}
+
+// void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
+static inline void qglBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glBufferData(target=%lu, size=%ld, data=%p, usage=%lu)\n", target, size, data, usage);
+#endif
+    glBufferData(target, size, data, usage);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glBufferData");
+#endif
+}
+
+// void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
+static inline void qglBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glBufferSubData(target=%lu, offset=%ld, size=%ld, data=%p)\n", target, offset, size, data);
+#endif
+    glBufferSubData(target, offset, size, data);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glBufferSubData");
+#endif
+}
+
+// void glClear (GLbitfield mask);
+static inline void qglClear(GLbitfield mask)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClear(mask=%lu)\n", mask);
+#endif
+    glClear(mask);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClear");
+#endif
+}
+
+// void glClearColorx (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
+static inline void qglClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClearColorx(red=%ld, green=%ld, blue=%ld, alpha=%ld)\n", red, green, blue, alpha);
+#endif
+    glClearColorx(red, green, blue, alpha);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClearColorx");
+#endif
+}
+
+// void glClearDepthx (GLclampx depth);
+static inline void qglClearDepthx(GLclampx depth)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClearDepthx(depth=%ld)\n", depth);
+#endif
+    glClearDepthx(depth);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClearDepthx");
+#endif
+}
+
+// void glClearStencil (GLint s);
+static inline void qglClearStencil(GLint s)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClearStencil(s=%ld)\n", s);
+#endif
+    glClearStencil(s);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClearStencil");
+#endif
+}
+
+// void glClientActiveTexture (GLenum texture);
+static inline void qglClientActiveTexture(GLenum texture)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClientActiveTexture(texture=%lu)\n", texture);
+#endif
+    glClientActiveTexture(texture);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClientActiveTexture");
+#endif
+}
+
+// void glClipPlanex (GLenum plane, const GLfixed *equation);
+static inline void qglClipPlanex(GLenum plane, const GLfixed *equation)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glClipPlanex(plane=%lu, equation=%p)\n", plane, equation);
+#endif
+    glClipPlanex(plane, equation);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glClipPlanex");
+#endif
+}
+
+// void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
+static inline void qglColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glColor4ub(red=%u, green=%u, blue=%u, alpha=%u)\n", red, green, blue, alpha);
+#endif
+    glColor4ub(red, green, blue, alpha);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glColor4ub");
+#endif
+}
+
+// void glColor4x (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
+static inline void qglColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glColor4x(red=%ld, green=%ld, blue=%ld, alpha=%ld)\n", red, green, blue, alpha);
+#endif
+    glColor4x(red, green, blue, alpha);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glColor4x");
+#endif
+}
+
+// void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+static inline void qglColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glColorMask(red=%u, green=%u, blue=%u, alpha=%u)\n", red, green, blue, alpha);
+#endif
+    glColorMask(red, green, blue, alpha);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glColorMask");
+#endif
+}
+
+// void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+static inline void qglColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glColorPointer(size=%ld, type=%lu, stride=%ld, pointer=%p)\n", size, type, stride, pointer);
+#endif
+    glColorPointer(size, type, stride, pointer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glColorPointer");
+#endif
+}
+
+// void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
+static inline void qglCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glCompressedTexImage2D(target=%lu, level=%ld, internalformat=%lu, width=%ld, height=%ld, border=%ld, imageSize=%ld, data=%p)\n", target, level, internalformat, width, height, border, imageSize, data);
+#endif
+    glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glCompressedTexImage2D");
+#endif
+}
+
+// void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
+static inline void qglCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glCompressedTexSubImage2D(target=%lu, level=%ld, xoffset=%ld, yoffset=%ld, width=%ld, height=%ld, format=%lu, imageSize=%ld, data=%p)\n", target, level, xoffset, yoffset, width, height, format, imageSize, data);
+#endif
+    glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glCompressedTexSubImage2D");
+#endif
+}
+
+// void glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+static inline void qglCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glCopyTexImage2D(target=%lu, level=%ld, internalformat=%lu, x=%ld, y=%ld, width=%ld, height=%ld, border=%ld)\n", target, level, internalformat, x, y, width, height, border);
+#endif
+    glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glCopyTexImage2D");
+#endif
+}
+
+// void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+static inline void qglCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glCopyTexSubImage2D(target=%lu, level=%ld, xoffset=%ld, yoffset=%ld, x=%ld, y=%ld, width=%ld, height=%ld)\n", target, level, xoffset, yoffset, x, y, width, height);
+#endif
+    glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glCopyTexSubImage2D");
+#endif
+}
+
+// void glCullFace (GLenum mode);
+static inline void qglCullFace(GLenum mode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glCullFace(mode=%lu)\n", mode);
+#endif
+    glCullFace(mode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glCullFace");
+#endif
+}
+
+// void glDeleteBuffers (GLsizei n, const GLuint *buffers);
+static inline void qglDeleteBuffers(GLsizei n, const GLuint *buffers)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDeleteBuffers(n=%ld, buffers=%p)\n", n, buffers);
+#endif
+    glDeleteBuffers(n, buffers);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDeleteBuffers");
+#endif
+}
+
+// void glDeleteTextures (GLsizei n, const GLuint *textures);
+static inline void qglDeleteTextures(GLsizei n, const GLuint *textures)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDeleteTextures(n=%ld, textures=%p)\n", n, textures);
+#endif
+    glDeleteTextures(n, textures);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDeleteTextures");
+#endif
+}
+
+// void glDepthFunc (GLenum func);
+static inline void qglDepthFunc(GLenum func)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDepthFunc(func=%lu)\n", func);
+#endif
+    glDepthFunc(func);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDepthFunc");
+#endif
+}
+
+// void glDepthMask (GLboolean flag);
+static inline void qglDepthMask(GLboolean flag)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDepthMask(flag=%u)\n", flag);
+#endif
+    glDepthMask(flag);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDepthMask");
+#endif
+}
+
+// void glDepthRangex (GLclampx zNear, GLclampx zFar);
+static inline void qglDepthRangex(GLclampx zNear, GLclampx zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDepthRangex(zNear=%ld, zFar=%ld)\n", zNear, zFar);
+#endif
+    glDepthRangex(zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDepthRangex");
+#endif
+}
+
+// void glDisable (GLenum cap);
+static inline void qglDisable(GLenum cap)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDisable(cap=%lu)\n", cap);
+#endif
+    glDisable(cap);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDisable");
+#endif
+}
+
+// void glDisableClientState (GLenum array);
+static inline void qglDisableClientState(GLenum array)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDisableClientState(array=%lu)\n", array);
+#endif
+    glDisableClientState(array);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDisableClientState");
+#endif
+}
+
+// void glDrawArrays (GLenum mode, GLint first, GLsizei count);
+static inline void qglDrawArrays(GLenum mode, GLint first, GLsizei count)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDrawArrays(mode=%lu, first=%ld, count=%ld)\n", mode, first, count);
+#endif
+    glDrawArrays(mode, first, count);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDrawArrays");
+#endif
+}
+
+// void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
+static inline void qglDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glDrawElements(mode=%lu, count=%ld, type=%lu, indices=%p)\n", mode, count, type, indices);
+#endif
+    glDrawElements(mode, count, type, indices);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glDrawElements");
+#endif
+}
+
+// void glEnable (GLenum cap);
+static inline void qglEnable(GLenum cap)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glEnable(cap=%lu)\n", cap);
+#endif
+    glEnable(cap);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glEnable");
+#endif
+}
+
+// void glEnableClientState (GLenum array);
+static inline void qglEnableClientState(GLenum array)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glEnableClientState(array=%lu)\n", array);
+#endif
+    glEnableClientState(array);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glEnableClientState");
+#endif
+}
+
+// void glFinish (void);
+static inline void qglFinish(void)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFinish(void)\n");
+#endif
+    glFinish();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFinish");
+#endif
+}
+
+// void glFlush (void);
+static inline void qglFlush(void)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFlush(void)\n");
+#endif
+    glFlush();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFlush");
+#endif
+}
+
+// void glFogx (GLenum pname, GLfixed param);
+static inline void qglFogx(GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFogx(pname=%lu, param=%ld)\n", pname, param);
+#endif
+    glFogx(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFogx");
+#endif
+}
+
+// void glFogxv (GLenum pname, const GLfixed *params);
+static inline void qglFogxv(GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFogxv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glFogxv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFogxv");
+#endif
+}
+
+// void glFrontFace (GLenum mode);
+static inline void qglFrontFace(GLenum mode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFrontFace(mode=%lu)\n", mode);
+#endif
+    glFrontFace(mode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFrontFace");
+#endif
+}
+
+// void glFrustumx (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
+static inline void qglFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glFrustumx(left=%ld, right=%ld, bottom=%ld, top=%ld, zNear=%ld, zFar=%ld)\n", left, right, bottom, top, zNear, zFar);
+#endif
+    glFrustumx(left, right, bottom, top, zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glFrustumx");
+#endif
+}
+
+// void glGetBooleanv (GLenum pname, GLboolean *params);
+static inline void qglGetBooleanv(GLenum pname, GLboolean *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetBooleanv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glGetBooleanv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetBooleanv");
+#endif
+}
+
+// void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
+static inline void qglGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetBufferParameteriv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glGetBufferParameteriv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetBufferParameteriv");
+#endif
+}
+
+// void glGetClipPlanex (GLenum pname, GLfixed eqn[4]);
+static inline void qglGetClipPlanex(GLenum pname, GLfixed eqn[4])
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetClipPlanex(pname=%lu, eqn=%ld)\n", pname, eqn);
+#endif
+    glGetClipPlanex(pname, eqn);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetClipPlanex");
+#endif
+}
+
+// void glGenBuffers (GLsizei n, GLuint *buffers);
+static inline void qglGenBuffers(GLsizei n, GLuint *buffers)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGenBuffers(n=%ld, buffers=%p)\n", n, buffers);
+#endif
+    glGenBuffers(n, buffers);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGenBuffers");
+#endif
+}
+
+// void glGenTextures (GLsizei n, GLuint *textures);
+static inline void qglGenTextures(GLsizei n, GLuint *textures)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGenTextures(n=%ld, textures=%p)\n", n, textures);
+#endif
+    glGenTextures(n, textures);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGenTextures");
+#endif
+}
+
+// GLenum glGetError (void);
+static inline GLenum qglGetError(void)
+{
+    GLenum returnValue;
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetError(void)\n");
+#endif
+    returnValue = glGetError();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetError");
+#endif
+    return returnValue;
+}
+
+// void glGetFixedv (GLenum pname, GLfixed *params);
+static inline void qglGetFixedv(GLenum pname, GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetFixedv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glGetFixedv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetFixedv");
+#endif
+}
+
+// void glGetIntegerv (GLenum pname, GLint *params);
+static inline void qglGetIntegerv(GLenum pname, GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetIntegerv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glGetIntegerv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetIntegerv");
+#endif
+}
+
+// void glGetLightxv (GLenum light, GLenum pname, GLfixed *params);
+static inline void qglGetLightxv(GLenum light, GLenum pname, GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetLightxv(light=%lu, pname=%lu, params=%p)\n", light, pname, params);
+#endif
+    glGetLightxv(light, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetLightxv");
+#endif
+}
+
+// void glGetMaterialxv (GLenum face, GLenum pname, GLfixed *params);
+static inline void qglGetMaterialxv(GLenum face, GLenum pname, GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetMaterialxv(face=%lu, pname=%lu, params=%p)\n", face, pname, params);
+#endif
+    glGetMaterialxv(face, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetMaterialxv");
+#endif
+}
+
+// void glGetPointerv (GLenum pname, void **params);
+static inline void qglGetPointerv(GLenum pname, void **params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetPointerv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glGetPointerv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetPointerv");
+#endif
+}
+
+// const GLubyte * glGetString (GLenum name);
+static inline const GLubyte * qglGetString(GLenum name)
+{
+    const GLubyte * returnValue;
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetString(name=%lu)\n", name);
+#endif
+    returnValue = glGetString(name);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetString");
+#endif
+    return returnValue;
+}
+
+// void glGetTexEnviv (GLenum env, GLenum pname, GLint *params);
+static inline void qglGetTexEnviv(GLenum env, GLenum pname, GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexEnviv(env=%lu, pname=%lu, params=%p)\n", env, pname, params);
+#endif
+    glGetTexEnviv(env, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexEnviv");
+#endif
+}
+
+// void glGetTexEnvxv (GLenum env, GLenum pname, GLfixed *params);
+static inline void qglGetTexEnvxv(GLenum env, GLenum pname, GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexEnvxv(env=%lu, pname=%lu, params=%p)\n", env, pname, params);
+#endif
+    glGetTexEnvxv(env, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexEnvxv");
+#endif
+}
+
+// void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
+static inline void qglGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexParameteriv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glGetTexParameteriv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexParameteriv");
+#endif
+}
+
+// void glGetTexParameterxv (GLenum target, GLenum pname, GLfixed *params);
+static inline void qglGetTexParameterxv(GLenum target, GLenum pname, GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glGetTexParameterxv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glGetTexParameterxv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glGetTexParameterxv");
+#endif
+}
+
+// void glHint (GLenum target, GLenum mode);
+static inline void qglHint(GLenum target, GLenum mode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glHint(target=%lu, mode=%lu)\n", target, mode);
+#endif
+    glHint(target, mode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glHint");
+#endif
+}
+
+// GLboolean glIsBuffer (GLuint buffer);
+static inline GLboolean qglIsBuffer(GLuint buffer)
+{
+    GLboolean returnValue;
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glIsBuffer(buffer=%lu)\n", buffer);
+#endif
+    returnValue = glIsBuffer(buffer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glIsBuffer");
+#endif
+    return returnValue;
+}
+
+// GLboolean glIsEnabled (GLenum cap);
+static inline GLboolean qglIsEnabled(GLenum cap)
+{
+    GLboolean returnValue;
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glIsEnabled(cap=%lu)\n", cap);
+#endif
+    returnValue = glIsEnabled(cap);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glIsEnabled");
+#endif
+    return returnValue;
+}
+
+// GLboolean glIsTexture (GLuint texture);
+static inline GLboolean qglIsTexture(GLuint texture)
+{
+    GLboolean returnValue;
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glIsTexture(texture=%lu)\n", texture);
+#endif
+    returnValue = glIsTexture(texture);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glIsTexture");
+#endif
+    return returnValue;
+}
+
+// void glLightModelx (GLenum pname, GLfixed param);
+static inline void qglLightModelx(GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightModelx(pname=%lu, param=%ld)\n", pname, param);
+#endif
+    glLightModelx(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightModelx");
+#endif
+}
+
+// void glLightModelxv (GLenum pname, const GLfixed *params);
+static inline void qglLightModelxv(GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightModelxv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glLightModelxv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightModelxv");
+#endif
+}
+
+// void glLightx (GLenum light, GLenum pname, GLfixed param);
+static inline void qglLightx(GLenum light, GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightx(light=%lu, pname=%lu, param=%ld)\n", light, pname, param);
+#endif
+    glLightx(light, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightx");
+#endif
+}
+
+// void glLightxv (GLenum light, GLenum pname, const GLfixed *params);
+static inline void qglLightxv(GLenum light, GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLightxv(light=%lu, pname=%lu, params=%p)\n", light, pname, params);
+#endif
+    glLightxv(light, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLightxv");
+#endif
+}
+
+// void glLineWidthx (GLfixed width);
+static inline void qglLineWidthx(GLfixed width)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLineWidthx(width=%ld)\n", width);
+#endif
+    glLineWidthx(width);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLineWidthx");
+#endif
+}
+
+// void glLoadIdentity (void);
+static inline void qglLoadIdentity(void)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLoadIdentity(void)\n");
+#endif
+    glLoadIdentity();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLoadIdentity");
+#endif
+}
+
+// void glLoadMatrixx (const GLfixed *m);
+static inline void qglLoadMatrixx(const GLfixed *m)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLoadMatrixx(m=%p)\n", m);
+#endif
+    glLoadMatrixx(m);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLoadMatrixx");
+#endif
+}
+
+// void glLogicOp (GLenum opcode);
+static inline void qglLogicOp(GLenum opcode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glLogicOp(opcode=%lu)\n", opcode);
+#endif
+    glLogicOp(opcode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glLogicOp");
+#endif
+}
+
+// void glMaterialx (GLenum face, GLenum pname, GLfixed param);
+static inline void qglMaterialx(GLenum face, GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMaterialx(face=%lu, pname=%lu, param=%ld)\n", face, pname, param);
+#endif
+    glMaterialx(face, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMaterialx");
+#endif
+}
+
+// void glMaterialxv (GLenum face, GLenum pname, const GLfixed *params);
+static inline void qglMaterialxv(GLenum face, GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMaterialxv(face=%lu, pname=%lu, params=%p)\n", face, pname, params);
+#endif
+    glMaterialxv(face, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMaterialxv");
+#endif
+}
+
+// void glMatrixMode (GLenum mode);
+static inline void qglMatrixMode(GLenum mode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMatrixMode(mode=%lu)\n", mode);
+#endif
+    glMatrixMode(mode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMatrixMode");
+#endif
+}
+
+// void glMultMatrixx (const GLfixed *m);
+static inline void qglMultMatrixx(const GLfixed *m)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMultMatrixx(m=%p)\n", m);
+#endif
+    glMultMatrixx(m);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMultMatrixx");
+#endif
+}
+
+// void glMultiTexCoord4x (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
+static inline void qglMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glMultiTexCoord4x(target=%lu, s=%ld, t=%ld, r=%ld, q=%ld)\n", target, s, t, r, q);
+#endif
+    glMultiTexCoord4x(target, s, t, r, q);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glMultiTexCoord4x");
+#endif
+}
+
+// void glNormal3x (GLfixed nx, GLfixed ny, GLfixed nz);
+static inline void qglNormal3x(GLfixed nx, GLfixed ny, GLfixed nz)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glNormal3x(nx=%ld, ny=%ld, nz=%ld)\n", nx, ny, nz);
+#endif
+    glNormal3x(nx, ny, nz);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glNormal3x");
+#endif
+}
+
+// void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
+static inline void qglNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glNormalPointer(type=%lu, stride=%ld, pointer=%p)\n", type, stride, pointer);
+#endif
+    glNormalPointer(type, stride, pointer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glNormalPointer");
+#endif
+}
+
+// void glOrthox (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
+static inline void qglOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glOrthox(left=%ld, right=%ld, bottom=%ld, top=%ld, zNear=%ld, zFar=%ld)\n", left, right, bottom, top, zNear, zFar);
+#endif
+    glOrthox(left, right, bottom, top, zNear, zFar);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glOrthox");
+#endif
+}
+
+// void glPixelStorei (GLenum pname, GLint param);
+static inline void qglPixelStorei(GLenum pname, GLint param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPixelStorei(pname=%lu, param=%ld)\n", pname, param);
+#endif
+    glPixelStorei(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPixelStorei");
+#endif
+}
+
+// void glPointParameterx (GLenum pname, GLfixed param);
+static inline void qglPointParameterx(GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointParameterx(pname=%lu, param=%ld)\n", pname, param);
+#endif
+    glPointParameterx(pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointParameterx");
+#endif
+}
+
+// void glPointParameterxv (GLenum pname, const GLfixed *params);
+static inline void qglPointParameterxv(GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointParameterxv(pname=%lu, params=%p)\n", pname, params);
+#endif
+    glPointParameterxv(pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointParameterxv");
+#endif
+}
+
+// void glPointSizex (GLfixed size);
+static inline void qglPointSizex(GLfixed size)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointSizex(size=%ld)\n", size);
+#endif
+    glPointSizex(size);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointSizex");
+#endif
+}
+
+// void glPolygonOffsetx (GLfixed factor, GLfixed units);
+static inline void qglPolygonOffsetx(GLfixed factor, GLfixed units)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPolygonOffsetx(factor=%ld, units=%ld)\n", factor, units);
+#endif
+    glPolygonOffsetx(factor, units);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPolygonOffsetx");
+#endif
+}
+
+// void glPopMatrix (void);
+static inline void qglPopMatrix(void)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPopMatrix(void)\n");
+#endif
+    glPopMatrix();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPopMatrix");
+#endif
+}
+
+// void glPushMatrix (void);
+static inline void qglPushMatrix(void)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPushMatrix(void)\n");
+#endif
+    glPushMatrix();
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPushMatrix");
+#endif
+}
+
+// void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
+static inline void qglReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glReadPixels(x=%ld, y=%ld, width=%ld, height=%ld, format=%lu, type=%lu, pixels=%p)\n", x, y, width, height, format, type, pixels);
+#endif
+    glReadPixels(x, y, width, height, format, type, pixels);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glReadPixels");
+#endif
+}
+
+// void glRotatex (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
+static inline void qglRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glRotatex(angle=%ld, x=%ld, y=%ld, z=%ld)\n", angle, x, y, z);
+#endif
+    glRotatex(angle, x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glRotatex");
+#endif
+}
+
+// void glSampleCoverage (GLclampf value, GLboolean invert);
+static inline void qglSampleCoverage(GLclampf value, GLboolean invert)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glSampleCoverage(value=%f, invert=%u)\n", value, invert);
+#endif
+    glSampleCoverage(value, invert);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glSampleCoverage");
+#endif
+}
+
+// void glSampleCoveragex (GLclampx value, GLboolean invert);
+static inline void qglSampleCoveragex(GLclampx value, GLboolean invert)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glSampleCoveragex(value=%ld, invert=%u)\n", value, invert);
+#endif
+    glSampleCoveragex(value, invert);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glSampleCoveragex");
+#endif
+}
+
+// void glScalex (GLfixed x, GLfixed y, GLfixed z);
+static inline void qglScalex(GLfixed x, GLfixed y, GLfixed z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glScalex(x=%ld, y=%ld, z=%ld)\n", x, y, z);
+#endif
+    glScalex(x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glScalex");
+#endif
+}
+
+// void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
+static inline void qglScissor(GLint x, GLint y, GLsizei width, GLsizei height)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glScissor(x=%ld, y=%ld, width=%ld, height=%ld)\n", x, y, width, height);
+#endif
+    glScissor(x, y, width, height);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glScissor");
+#endif
+}
+
+// void glShadeModel (GLenum mode);
+static inline void qglShadeModel(GLenum mode)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glShadeModel(mode=%lu)\n", mode);
+#endif
+    glShadeModel(mode);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glShadeModel");
+#endif
+}
+
+// void glStencilFunc (GLenum func, GLint ref, GLuint mask);
+static inline void qglStencilFunc(GLenum func, GLint ref, GLuint mask)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glStencilFunc(func=%lu, ref=%ld, mask=%lu)\n", func, ref, mask);
+#endif
+    glStencilFunc(func, ref, mask);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glStencilFunc");
+#endif
+}
+
+// void glStencilMask (GLuint mask);
+static inline void qglStencilMask(GLuint mask)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glStencilMask(mask=%lu)\n", mask);
+#endif
+    glStencilMask(mask);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glStencilMask");
+#endif
+}
+
+// void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
+static inline void qglStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glStencilOp(fail=%lu, zfail=%lu, zpass=%lu)\n", fail, zfail, zpass);
+#endif
+    glStencilOp(fail, zfail, zpass);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glStencilOp");
+#endif
+}
+
+// void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+static inline void qglTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexCoordPointer(size=%ld, type=%lu, stride=%ld, pointer=%p)\n", size, type, stride, pointer);
+#endif
+    glTexCoordPointer(size, type, stride, pointer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexCoordPointer");
+#endif
+}
+
+// void glTexEnvi (GLenum target, GLenum pname, GLint param);
+static inline void qglTexEnvi(GLenum target, GLenum pname, GLint param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnvi(target=%lu, pname=%lu, param=%ld)\n", target, pname, param);
+#endif
+    glTexEnvi(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnvi");
+#endif
+}
+
+// void glTexEnvx (GLenum target, GLenum pname, GLfixed param);
+static inline void qglTexEnvx(GLenum target, GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnvx(target=%lu, pname=%lu, param=%ld)\n", target, pname, param);
+#endif
+    glTexEnvx(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnvx");
+#endif
+}
+
+// void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
+static inline void qglTexEnviv(GLenum target, GLenum pname, const GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnviv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexEnviv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnviv");
+#endif
+}
+
+// void glTexEnvxv (GLenum target, GLenum pname, const GLfixed *params);
+static inline void qglTexEnvxv(GLenum target, GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexEnvxv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexEnvxv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexEnvxv");
+#endif
+}
+
+// void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+static inline void qglTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexImage2D(target=%lu, level=%ld, internalformat=%ld, width=%ld, height=%ld, border=%ld, format=%lu, type=%lu, pixels=%p)\n", target, level, internalformat, width, height, border, format, type, pixels);
+#endif
+    glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexImage2D");
+#endif
+}
+
+// void glTexParameteri (GLenum target, GLenum pname, GLint param);
+static inline void qglTexParameteri(GLenum target, GLenum pname, GLint param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameteri(target=%lu, pname=%lu, param=%ld)\n", target, pname, param);
+#endif
+    glTexParameteri(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameteri");
+#endif
+}
+
+// void glTexParameterx (GLenum target, GLenum pname, GLfixed param);
+static inline void qglTexParameterx(GLenum target, GLenum pname, GLfixed param)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameterx(target=%lu, pname=%lu, param=%ld)\n", target, pname, param);
+#endif
+    glTexParameterx(target, pname, param);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameterx");
+#endif
+}
+
+// void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
+static inline void qglTexParameteriv(GLenum target, GLenum pname, const GLint *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameteriv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexParameteriv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameteriv");
+#endif
+}
+
+// void glTexParameterxv (GLenum target, GLenum pname, const GLfixed *params);
+static inline void qglTexParameterxv(GLenum target, GLenum pname, const GLfixed *params)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexParameterxv(target=%lu, pname=%lu, params=%p)\n", target, pname, params);
+#endif
+    glTexParameterxv(target, pname, params);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexParameterxv");
+#endif
+}
+
+// void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+static inline void qglTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTexSubImage2D(target=%lu, level=%ld, xoffset=%ld, yoffset=%ld, width=%ld, height=%ld, format=%lu, type=%lu, pixels=%p)\n", target, level, xoffset, yoffset, width, height, format, type, pixels);
+#endif
+    glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTexSubImage2D");
+#endif
+}
+
+// void glTranslatex (GLfixed x, GLfixed y, GLfixed z);
+static inline void qglTranslatex(GLfixed x, GLfixed y, GLfixed z)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glTranslatex(x=%ld, y=%ld, z=%ld)\n", x, y, z);
+#endif
+    glTranslatex(x, y, z);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glTranslatex");
+#endif
+}
+
+// void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+static inline void qglVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glVertexPointer(size=%ld, type=%lu, stride=%ld, pointer=%p)\n", size, type, stride, pointer);
+#endif
+    glVertexPointer(size, type, stride, pointer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glVertexPointer");
+#endif
+}
+
+// void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
+static inline void qglViewport(GLint x, GLint y, GLsizei width, GLsizei height)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glViewport(x=%ld, y=%ld, width=%ld, height=%ld)\n", x, y, width, height);
+#endif
+    glViewport(x, y, width, height);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glViewport");
+#endif
+}
+
+// void glPointSizePointerOES (GLenum type, GLsizei stride, const GLvoid *pointer);
+static inline void qglPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid *pointer)
+{
+#if !defined(NDEBUG) && defined(QGL_LOG_GL_CALLS)
+    if (QGLLogGLCalls)
+        fprintf(QGLDebugFile(), "glPointSizePointerOES(type=%lu, stride=%ld, pointer=%p)\n", type, stride, pointer);
+#endif
+    glPointSizePointerOES(type, stride, pointer);
+#if !defined(NDEBUG) && defined(QGL_CHECK_GL_ERRORS)
+    if (!QGLBeginStarted)
+        QGLCheckError("glPointSizePointerOES");
+#endif
+}
+
+// Prevent calls to the 'normal' GL functions
+#define glAlphaFunc CALL_THE_QGL_VERSION_OF_glAlphaFunc
+#define glClearColor CALL_THE_QGL_VERSION_OF_glClearColor
+#define glClearDepthf CALL_THE_QGL_VERSION_OF_glClearDepthf
+#define glClipPlanef CALL_THE_QGL_VERSION_OF_glClipPlanef
+#define glDepthRangef CALL_THE_QGL_VERSION_OF_glDepthRangef
+#define glFogf CALL_THE_QGL_VERSION_OF_glFogf
+#define glFogfv CALL_THE_QGL_VERSION_OF_glFogfv
+#define glFrustumf CALL_THE_QGL_VERSION_OF_glFrustumf
+#define glGetClipPlanef CALL_THE_QGL_VERSION_OF_glGetClipPlanef
+#define glGetFloatv CALL_THE_QGL_VERSION_OF_glGetFloatv
+#define glGetLightfv CALL_THE_QGL_VERSION_OF_glGetLightfv
+#define glGetMaterialfv CALL_THE_QGL_VERSION_OF_glGetMaterialfv
+#define glGetTexEnvfv CALL_THE_QGL_VERSION_OF_glGetTexEnvfv
+#define glGetTexParameterfv CALL_THE_QGL_VERSION_OF_glGetTexParameterfv
+#define glLightModelf CALL_THE_QGL_VERSION_OF_glLightModelf
+#define glLightModelfv CALL_THE_QGL_VERSION_OF_glLightModelfv
+#define glLightf CALL_THE_QGL_VERSION_OF_glLightf
+#define glLightfv CALL_THE_QGL_VERSION_OF_glLightfv
+#define glLineWidth CALL_THE_QGL_VERSION_OF_glLineWidth
+#define glLoadMatrixf CALL_THE_QGL_VERSION_OF_glLoadMatrixf
+#define glMaterialf CALL_THE_QGL_VERSION_OF_glMaterialf
+#define glMaterialfv CALL_THE_QGL_VERSION_OF_glMaterialfv
+#define glMultMatrixf CALL_THE_QGL_VERSION_OF_glMultMatrixf
+#define glMultiTexCoord4f CALL_THE_QGL_VERSION_OF_glMultiTexCoord4f
+#define glNormal3f CALL_THE_QGL_VERSION_OF_glNormal3f
+#define glOrthof CALL_THE_QGL_VERSION_OF_glOrthof
+#define glPointParameterf CALL_THE_QGL_VERSION_OF_glPointParameterf
+#define glPointParameterfv CALL_THE_QGL_VERSION_OF_glPointParameterfv
+#define glPointSize CALL_THE_QGL_VERSION_OF_glPointSize
+#define glPolygonOffset CALL_THE_QGL_VERSION_OF_glPolygonOffset
+#define glRotatef CALL_THE_QGL_VERSION_OF_glRotatef
+#define glScalef CALL_THE_QGL_VERSION_OF_glScalef
+#define glTexEnvf CALL_THE_QGL_VERSION_OF_glTexEnvf
+#define glTexEnvfv CALL_THE_QGL_VERSION_OF_glTexEnvfv
+#define glTexParameterf CALL_THE_QGL_VERSION_OF_glTexParameterf
+#define glTexParameterfv CALL_THE_QGL_VERSION_OF_glTexParameterfv
+#define glTranslatef CALL_THE_QGL_VERSION_OF_glTranslatef
+#define glActiveTexture CALL_THE_QGL_VERSION_OF_glActiveTexture
+#define glAlphaFuncx CALL_THE_QGL_VERSION_OF_glAlphaFuncx
+#define glBindBuffer CALL_THE_QGL_VERSION_OF_glBindBuffer
+#define glBindTexture CALL_THE_QGL_VERSION_OF_glBindTexture
+#define glBlendFunc CALL_THE_QGL_VERSION_OF_glBlendFunc
+#define glBufferData CALL_THE_QGL_VERSION_OF_glBufferData
+#define glBufferSubData CALL_THE_QGL_VERSION_OF_glBufferSubData
+#define glClear CALL_THE_QGL_VERSION_OF_glClear
+#define glClearColorx CALL_THE_QGL_VERSION_OF_glClearColorx
+#define glClearDepthx CALL_THE_QGL_VERSION_OF_glClearDepthx
+#define glClearStencil CALL_THE_QGL_VERSION_OF_glClearStencil
+#define glClientActiveTexture CALL_THE_QGL_VERSION_OF_glClientActiveTexture
+#define glClipPlanex CALL_THE_QGL_VERSION_OF_glClipPlanex
+#define glColor4ub CALL_THE_QGL_VERSION_OF_glColor4ub
+#define glColor4x CALL_THE_QGL_VERSION_OF_glColor4x
+#define glColorMask CALL_THE_QGL_VERSION_OF_glColorMask
+#define glColorPointer CALL_THE_QGL_VERSION_OF_glColorPointer
+#define glCompressedTexImage2D CALL_THE_QGL_VERSION_OF_glCompressedTexImage2D
+#define glCompressedTexSubImage2D CALL_THE_QGL_VERSION_OF_glCompressedTexSubImage2D
+#define glCopyTexImage2D CALL_THE_QGL_VERSION_OF_glCopyTexImage2D
+#define glCopyTexSubImage2D CALL_THE_QGL_VERSION_OF_glCopyTexSubImage2D
+#define glCullFace CALL_THE_QGL_VERSION_OF_glCullFace
+#define glDeleteBuffers CALL_THE_QGL_VERSION_OF_glDeleteBuffers
+#define glDeleteTextures CALL_THE_QGL_VERSION_OF_glDeleteTextures
+#define glDepthFunc CALL_THE_QGL_VERSION_OF_glDepthFunc
+#define glDepthMask CALL_THE_QGL_VERSION_OF_glDepthMask
+#define glDepthRangex CALL_THE_QGL_VERSION_OF_glDepthRangex
+#define glDisable CALL_THE_QGL_VERSION_OF_glDisable
+#define glDisableClientState CALL_THE_QGL_VERSION_OF_glDisableClientState
+#define glDrawArrays CALL_THE_QGL_VERSION_OF_glDrawArrays
+#define glDrawElements CALL_THE_QGL_VERSION_OF_glDrawElements
+#define glEnable CALL_THE_QGL_VERSION_OF_glEnable
+#define glEnableClientState CALL_THE_QGL_VERSION_OF_glEnableClientState
+#define glFinish CALL_THE_QGL_VERSION_OF_glFinish
+#define glFlush CALL_THE_QGL_VERSION_OF_glFlush
+#define glFogx CALL_THE_QGL_VERSION_OF_glFogx
+#define glFogxv CALL_THE_QGL_VERSION_OF_glFogxv
+#define glFrontFace CALL_THE_QGL_VERSION_OF_glFrontFace
+#define glFrustumx CALL_THE_QGL_VERSION_OF_glFrustumx
+#define glGetBooleanv CALL_THE_QGL_VERSION_OF_glGetBooleanv
+#define glGetBufferParameteriv CALL_THE_QGL_VERSION_OF_glGetBufferParameteriv
+#define glGetClipPlanex CALL_THE_QGL_VERSION_OF_glGetClipPlanex
+#define glGenBuffers CALL_THE_QGL_VERSION_OF_glGenBuffers
+#define glGenTextures CALL_THE_QGL_VERSION_OF_glGenTextures
+#define glGetError CALL_THE_QGL_VERSION_OF_glGetError
+#define glGetFixedv CALL_THE_QGL_VERSION_OF_glGetFixedv
+#define glGetIntegerv CALL_THE_QGL_VERSION_OF_glGetIntegerv
+#define glGetLightxv CALL_THE_QGL_VERSION_OF_glGetLightxv
+#define glGetMaterialxv CALL_THE_QGL_VERSION_OF_glGetMaterialxv
+#define glGetPointerv CALL_THE_QGL_VERSION_OF_glGetPointerv
+#define glGetString CALL_THE_QGL_VERSION_OF_glGetString
+#define glGetTexEnviv CALL_THE_QGL_VERSION_OF_glGetTexEnviv
+#define glGetTexEnvxv CALL_THE_QGL_VERSION_OF_glGetTexEnvxv
+#define glGetTexParameteriv CALL_THE_QGL_VERSION_OF_glGetTexParameteriv
+#define glGetTexParameterxv CALL_THE_QGL_VERSION_OF_glGetTexParameterxv
+#define glHint CALL_THE_QGL_VERSION_OF_glHint
+#define glIsBuffer CALL_THE_QGL_VERSION_OF_glIsBuffer
+#define glIsEnabled CALL_THE_QGL_VERSION_OF_glIsEnabled
+#define glIsTexture CALL_THE_QGL_VERSION_OF_glIsTexture
+#define glLightModelx CALL_THE_QGL_VERSION_OF_glLightModelx
+#define glLightModelxv CALL_THE_QGL_VERSION_OF_glLightModelxv
+#define glLightx CALL_THE_QGL_VERSION_OF_glLightx
+#define glLightxv CALL_THE_QGL_VERSION_OF_glLightxv
+#define glLineWidthx CALL_THE_QGL_VERSION_OF_glLineWidthx
+#define glLoadIdentity CALL_THE_QGL_VERSION_OF_glLoadIdentity
+#define glLoadMatrixx CALL_THE_QGL_VERSION_OF_glLoadMatrixx
+#define glLogicOp CALL_THE_QGL_VERSION_OF_glLogicOp
+#define glMaterialx CALL_THE_QGL_VERSION_OF_glMaterialx
+#define glMaterialxv CALL_THE_QGL_VERSION_OF_glMaterialxv
+#define glMatrixMode CALL_THE_QGL_VERSION_OF_glMatrixMode
+#define glMultMatrixx CALL_THE_QGL_VERSION_OF_glMultMatrixx
+#define glMultiTexCoord4x CALL_THE_QGL_VERSION_OF_glMultiTexCoord4x
+#define glNormal3x CALL_THE_QGL_VERSION_OF_glNormal3x
+#define glNormalPointer CALL_THE_QGL_VERSION_OF_glNormalPointer
+#define glOrthox CALL_THE_QGL_VERSION_OF_glOrthox
+#define glPixelStorei CALL_THE_QGL_VERSION_OF_glPixelStorei
+#define glPointParameterx CALL_THE_QGL_VERSION_OF_glPointParameterx
+#define glPointParameterxv CALL_THE_QGL_VERSION_OF_glPointParameterxv
+#define glPointSizex CALL_THE_QGL_VERSION_OF_glPointSizex
+#define glPolygonOffsetx CALL_THE_QGL_VERSION_OF_glPolygonOffsetx
+#define glPopMatrix CALL_THE_QGL_VERSION_OF_glPopMatrix
+#define glPushMatrix CALL_THE_QGL_VERSION_OF_glPushMatrix
+#define glReadPixels CALL_THE_QGL_VERSION_OF_glReadPixels
+#define glRotatex CALL_THE_QGL_VERSION_OF_glRotatex
+#define glSampleCoverage CALL_THE_QGL_VERSION_OF_glSampleCoverage
+#define glSampleCoveragex CALL_THE_QGL_VERSION_OF_glSampleCoveragex
+#define glScalex CALL_THE_QGL_VERSION_OF_glScalex
+#define glScissor CALL_THE_QGL_VERSION_OF_glScissor
+#define glShadeModel CALL_THE_QGL_VERSION_OF_glShadeModel
+#define glStencilFunc CALL_THE_QGL_VERSION_OF_glStencilFunc
+#define glStencilMask CALL_THE_QGL_VERSION_OF_glStencilMask
+#define glStencilOp CALL_THE_QGL_VERSION_OF_glStencilOp
+#define glTexCoordPointer CALL_THE_QGL_VERSION_OF_glTexCoordPointer
+#define glTexEnvi CALL_THE_QGL_VERSION_OF_glTexEnvi
+#define glTexEnvx CALL_THE_QGL_VERSION_OF_glTexEnvx
+#define glTexEnviv CALL_THE_QGL_VERSION_OF_glTexEnviv
+#define glTexEnvxv CALL_THE_QGL_VERSION_OF_glTexEnvxv
+#define glTexImage2D CALL_THE_QGL_VERSION_OF_glTexImage2D
+#define glTexParameteri CALL_THE_QGL_VERSION_OF_glTexParameteri
+#define glTexParameterx CALL_THE_QGL_VERSION_OF_glTexParameterx
+#define glTexParameteriv CALL_THE_QGL_VERSION_OF_glTexParameteriv
+#define glTexParameterxv CALL_THE_QGL_VERSION_OF_glTexParameterxv
+#define glTexSubImage2D CALL_THE_QGL_VERSION_OF_glTexSubImage2D
+#define glTranslatex CALL_THE_QGL_VERSION_OF_glTranslatex
+#define glVertexPointer CALL_THE_QGL_VERSION_OF_glVertexPointer
+#define glViewport CALL_THE_QGL_VERSION_OF_glViewport
+#define glPointSizePointerOES CALL_THE_QGL_VERSION_OF_glPointSizePointerOES
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./egl/sdl_snd.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/sdl_snd.c
--- ./egl/sdl_snd.c	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/egl/sdl_snd.c	2012-05-25 14:17:11.973231571 +0300
@@ -0,0 +1,299 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+
+This file is part of Quake III Arena source code.
+
+Quake III Arena source code is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Quake III Arena source code is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Quake III Arena source code; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#ifdef USE_LOCAL_HEADERS
+#	include "SDL.h"
+#else
+#	include <SDL.h>
+#endif
+
+#include "../qcommon/q_shared.h"
+#include "../client/snd_local.h"
+
+qboolean snd_inited = qfalse;
+
+cvar_t *s_sdlBits;
+cvar_t *s_sdlSpeed;
+cvar_t *s_sdlChannels;
+cvar_t *s_sdlDevSamps;
+cvar_t *s_sdlMixSamps;
+
+/* The audio callback. All the magic happens here. */
+static int dmapos = 0;
+static int dmasize = 0;
+
+/*
+===============
+SNDDMA_AudioCallback
+===============
+*/
+static void SNDDMA_AudioCallback(void *userdata, Uint8 *stream, int len)
+{
+	int pos = (dmapos * (dma.samplebits/8));
+	if (pos >= dmasize)
+		dmapos = pos = 0;
+
+	if (!snd_inited)  /* shouldn't happen, but just in case... */
+	{
+		memset(stream, '\0', len);
+		return;
+	}
+	else
+	{
+		int tobufend = dmasize - pos;  /* bytes to buffer's end. */
+		int len1 = len;
+		int len2 = 0;
+
+		if (len1 > tobufend)
+		{
+			len1 = tobufend;
+			len2 = len - len1;
+		}
+		memcpy(stream, dma.buffer + pos, len1);
+		if (len2 <= 0)
+			dmapos += (len1 / (dma.samplebits/8));
+		else  /* wraparound? */
+		{
+			memcpy(stream+len1, dma.buffer, len2);
+			dmapos = (len2 / (dma.samplebits/8));
+		}
+	}
+
+	if (dmapos >= dmasize)
+		dmapos = 0;
+}
+
+static struct
+{
+	Uint16	enumFormat;
+	char		*stringFormat;
+} formatToStringTable[ ] =
+{
+	{ AUDIO_U8,     "AUDIO_U8" },
+	{ AUDIO_S8,     "AUDIO_S8" },
+	{ AUDIO_U16LSB, "AUDIO_U16LSB" },
+	{ AUDIO_S16LSB, "AUDIO_S16LSB" },
+	{ AUDIO_U16MSB, "AUDIO_U16MSB" },
+	{ AUDIO_S16MSB, "AUDIO_S16MSB" }
+};
+
+static int formatToStringTableSize =
+  sizeof( formatToStringTable ) / sizeof( formatToStringTable[ 0 ] );
+
+/*
+===============
+SNDDMA_PrintAudiospec
+===============
+*/
+static void SNDDMA_PrintAudiospec(const char *str, const SDL_AudioSpec *spec)
+{
+	int		i;
+	char	*fmt = NULL;
+
+	Com_Printf("%s:\n", str);
+
+	for( i = 0; i < formatToStringTableSize; i++ ) {
+		if( spec->format == formatToStringTable[ i ].enumFormat ) {
+			fmt = formatToStringTable[ i ].stringFormat;
+		}
+	}
+
+	if( fmt ) {
+		Com_Printf( "  Format:   %s\n", fmt );
+	} else {
+		Com_Printf( "  Format:   " S_COLOR_RED "UNKNOWN\n");
+	}
+
+	Com_Printf( "  Freq:     %d\n", (int) spec->freq );
+	Com_Printf( "  Samples:  %d\n", (int) spec->samples );
+	Com_Printf( "  Channels: %d\n", (int) spec->channels );
+}
+
+/*
+===============
+SNDDMA_Init
+===============
+*/
+qboolean SNDDMA_Init(void)
+{
+	char drivername[128];
+	SDL_AudioSpec desired;
+	SDL_AudioSpec obtained;
+	int tmp;
+
+	if (snd_inited)
+		return qtrue;
+
+	if (!s_sdlBits) {
+		s_sdlBits = Cvar_Get("s_sdlBits", "16", CVAR_ARCHIVE);
+		s_sdlSpeed = Cvar_Get("s_sdlSpeed", "0", CVAR_ARCHIVE);
+		s_sdlChannels = Cvar_Get("s_sdlChannels", "2", CVAR_ARCHIVE);
+		s_sdlDevSamps = Cvar_Get("s_sdlDevSamps", "0", CVAR_ARCHIVE);
+		s_sdlMixSamps = Cvar_Get("s_sdlMixSamps", "0", CVAR_ARCHIVE);
+	}
+
+	Com_Printf( "SDL_Init( SDL_INIT_AUDIO )... " );
+
+	if (!SDL_WasInit(SDL_INIT_AUDIO))
+	{
+		if (SDL_Init(SDL_INIT_AUDIO) == -1)
+		{
+			Com_Printf( "FAILED (%s)\n", SDL_GetError( ) );
+			return qfalse;
+		}
+	}
+
+	Com_Printf( "OK\n" );
+
+	if (SDL_AudioDriverName(drivername, sizeof (drivername)) == NULL)
+		strcpy(drivername, "(UNKNOWN)");
+	Com_Printf("SDL audio driver is \"%s\".\n", drivername);
+
+	memset(&desired, '\0', sizeof (desired));
+	memset(&obtained, '\0', sizeof (obtained));
+
+	tmp = ((int) s_sdlBits->value);
+	if ((tmp != 16) && (tmp != 8))
+		tmp = 16;
+
+	desired.freq = (int) s_sdlSpeed->value;
+	if(!desired.freq) desired.freq = 22050;
+	desired.format = ((tmp == 16) ? AUDIO_S16SYS : AUDIO_U8);
+
+	// I dunno if this is the best idea, but I'll give it a try...
+	//  should probably check a cvar for this...
+	if (s_sdlDevSamps->value)
+		desired.samples = s_sdlDevSamps->value;
+	else
+	{
+		// just pick a sane default.
+		if (desired.freq <= 11025)
+			desired.samples = 256;
+		else if (desired.freq <= 22050)
+			desired.samples = 512;
+		else if (desired.freq <= 44100)
+			desired.samples = 1024;
+		else
+			desired.samples = 2048;  // (*shrug*)
+	}
+
+	desired.channels = (int) s_sdlChannels->value;
+	desired.callback = SNDDMA_AudioCallback;
+
+	if (SDL_OpenAudio(&desired, &obtained) == -1)
+	{
+		Com_Printf("SDL_OpenAudio() failed: %s\n", SDL_GetError());
+		SDL_QuitSubSystem(SDL_INIT_AUDIO);
+		return qfalse;
+	}
+
+	SNDDMA_PrintAudiospec("SDL_AudioSpec", &obtained);
+
+	// dma.samples needs to be big, or id's mixer will just refuse to
+	//  work at all; we need to keep it significantly bigger than the
+	//  amount of SDL callback samples, and just copy a little each time
+	//  the callback runs.
+	// 32768 is what the OSS driver filled in here on my system. I don't
+	//  know if it's a good value overall, but at least we know it's
+	//  reasonable...this is why I let the user override.
+	tmp = s_sdlMixSamps->value;
+	if (!tmp)
+		tmp = (obtained.samples * obtained.channels) * 10;
+
+	if (tmp & (tmp - 1))  // not a power of two? Seems to confuse something.
+	{
+		int val = 1;
+		while (val < tmp)
+			val <<= 1;
+
+		tmp = val;
+	}
+
+	dmapos = 0;
+	dma.samplebits = obtained.format & 0xFF;  // first byte of format is bits.
+	dma.channels = obtained.channels;
+	dma.samples = tmp;
+	dma.submission_chunk = 1;
+	dma.speed = obtained.freq;
+	dmasize = (dma.samples * (dma.samplebits/8));
+	dma.buffer = calloc(1, dmasize);
+
+	Com_Printf("Starting SDL audio callback...\n");
+	SDL_PauseAudio(0);  // start callback.
+
+	Com_Printf("SDL audio initialized.\n");
+	snd_inited = qtrue;
+	return qtrue;
+}
+
+/*
+===============
+SNDDMA_GetDMAPos
+===============
+*/
+int SNDDMA_GetDMAPos(void)
+{
+	return dmapos;
+}
+
+/*
+===============
+SNDDMA_Shutdown
+===============
+*/
+void SNDDMA_Shutdown(void)
+{
+	Com_Printf("Closing SDL audio device...\n");
+	SDL_PauseAudio(1);
+	SDL_CloseAudio();
+	SDL_QuitSubSystem(SDL_INIT_AUDIO);
+	free(dma.buffer);
+	dma.buffer = NULL;
+	dmapos = dmasize = 0;
+	snd_inited = qfalse;
+	Com_Printf("SDL audio device shut down.\n");
+}
+
+/*
+===============
+SNDDMA_Submit
+
+Send sound to device if buffer isn't really the dma buffer
+===============
+*/
+void SNDDMA_Submit(void)
+{
+	SDL_UnlockAudio();
+}
+
+/*
+===============
+SNDDMA_BeginPainting
+===============
+*/
+void SNDDMA_BeginPainting (void)
+{
+	SDL_LockAudio();
+}
Only in ./libs/macosx: libSDL-1.2.0.dylib
Only in ./libs/macosx: libSDLmain.a
Only in ./libs/win32: libcurl.a
Only in ./libs/win32: libSDL.dll.a
Only in ./libs/win32: libSDL.la
Only in ./libs/win32: libSDLmain.a
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./q3_ui/ui_atoms.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/q3_ui/ui_atoms.c
--- ./q3_ui/ui_atoms.c	2012-05-25 15:50:37.813180248 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/q3_ui/ui_atoms.c	2012-05-25 14:17:10.209231589 +0300
@@ -873,18 +873,18 @@
 {
 	int				i;
 	menucommon_s*	m;
-
+	//printf(__FILE__ " UI_MouseEvent(%d,%d)\n", dx, dy);
 	if (!uis.activemenu)
 		return;
 
 	// update mouse screen position
-	uis.cursorx += dx;
+	uis.cursorx = dx;
 	if (uis.cursorx < 0)
 		uis.cursorx = 0;
 	else if (uis.cursorx > SCREEN_WIDTH)
 		uis.cursorx = SCREEN_WIDTH;
 
-	uis.cursory += dy;
+	uis.cursory = dy;
 	if (uis.cursory < 0)
 		uis.cursory = 0;
 	else if (uis.cursory > SCREEN_HEIGHT)
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./qcommon/common.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/common.c
--- ./qcommon/common.c	2012-05-25 15:54:55.481177889 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/common.c	2012-05-25 14:17:13.009231563 +0300
@@ -2232,6 +2232,9 @@
 		case SE_MOUSE:
 			CL_MouseEvent( ev.evValue, ev.evValue2, ev.evTime );
 			break;
+		case SE_ACCEL:
+			CL_AccelEvent( ev.evValue, ev.evValue2, ev.evTime );
+			break;
 		case SE_JOYSTICK_AXIS:
 			CL_JoystickEvent( ev.evValue, ev.evValue2, ev.evTime );
 			break;
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./qcommon/net_ip.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/net_ip.c
--- ./qcommon/net_ip.c	2012-05-25 15:54:56.809177876 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/net_ip.c	2012-05-25 14:17:13.009231563 +0300
@@ -72,10 +72,21 @@
 #	include <sys/types.h>
 #	include <sys/time.h>
 #	include <unistd.h>
-#	if !defined(__sun) && !defined(__sgi)
+#	if !defined(ANDROID) && !defined(__sun) && !defined(__sgi)
 #		include <ifaddrs.h>
 #	endif
 
+	/* Old versions of the Android NDK had buggy ipv6 headers */
+	#if defined(ANDROID) && !defined(IN6ADDR_ANY_INIT)
+		#define IPV6_JOIN_GROUP IPV6_ADD_MEMBERSHIP
+		#define IPV6_LEAVE_GROUP IPV6_DROP_MEMBERSHIP
+		#define ipv6mr_interface ipv6mr_ifindex
+
+		#define IN6ADDR_ANY_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
+		static const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
+		static const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;
+	#endif
+
 #	ifdef __sun
 #		include <sys/filio.h>
 #	endif
@@ -126,6 +137,7 @@
 // And the currently bound address.
 static struct sockaddr_in6 boundto;
 
+
 #ifndef IF_NAMESIZE
   #define IF_NAMESIZE 16
 #endif
@@ -1300,7 +1312,7 @@
 	}
 }
 
-#if defined(__linux__) || defined(MACOSX) || defined(__BSD__)
+#if (defined(__linux__) && !defined(ANDROID)) || defined(MACOSX) || defined(__BSD__)
 void NET_GetLocalAddress(void)
 {
 	struct ifaddrs *ifap, *search;
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./qcommon/qcommon.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/qcommon.h
--- ./qcommon/qcommon.h	2012-05-25 15:54:56.809177876 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/qcommon.h	2012-05-25 14:17:13.009231563 +0300
@@ -759,7 +759,8 @@
 	SE_NONE = 0,	// evTime is still valid
 	SE_KEY,		// evValue is a key code, evValue2 is the down flag
 	SE_CHAR,	// evValue is an ascii char
-	SE_MOUSE,	// evValue and evValue2 are reletive signed x / y moves
+	SE_MOUSE,	// evValue and evValue2 are relative signed x / y moves
+	SE_ACCEL,
 	SE_JOYSTICK_AXIS,	// evValue is an axis number and evValue2 is the current state (-127 to 127)
 	SE_CONSOLE,	// evPtr is a char*
 	SE_PACKET	// evPtr is a netadr_t followed by data bytes to evPtrLength
@@ -934,6 +935,7 @@
 // char events are for field typing, not game control
 
 void CL_MouseEvent( int dx, int dy, int time );
+void CL_AccelEvent( int dx, int dy, int time );
 
 void CL_JoystickEvent( int axis, int value, int time );
 
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./qcommon/q_math.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/q_math.c
--- ./qcommon/q_math.c	2012-05-25 15:53:12.241178835 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/q_math.c	2012-05-25 14:17:13.001231562 +0300
@@ -495,7 +495,7 @@
 
 //============================================================================
 
-#if !idppc
+#if !idppc && !idarm
 /*
 ** float q_rsqrt( float number )
 */
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./qcommon/q_platform.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/q_platform.h
--- ./qcommon/q_platform.h	2012-05-25 15:53:12.241178835 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/q_platform.h	2012-05-25 14:17:13.001231562 +0300
@@ -30,6 +30,7 @@
 #define idppc 0
 #define idppc_altivec 0
 #define idsparc 0
+#define idarm 0
 
 #else
 
@@ -65,6 +66,12 @@
 #define idsparc 0
 #endif
 
+#if defined(__ARMEL__)
+#define idarm 1
+#else
+#define idarm 0
+#endif
+
 #endif
 
 #ifndef __ASM_I386__ // don't include the C bits if included from qasm.h
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./qcommon/q_shared.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/q_shared.h
--- ./qcommon/q_shared.h	2012-05-25 15:53:12.245178835 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/q_shared.h	2012-05-25 14:17:13.009231563 +0300
@@ -26,19 +26,11 @@
 // q_shared.h -- included first by ALL program modules.
 // A user mod should never modify this file
 
-#ifdef STANDALONE
-  #define PRODUCT_NAME			"iofoo3"
-  #define BASEGAME			"foobar"
-  #define CLIENT_WINDOW_TITLE     	"changeme"
-  #define CLIENT_WINDOW_MIN_TITLE 	"changeme2"
-  #define GAMENAME_FOR_MASTER		"iofoo3"	// must NOT contain whitespaces
-#else
-  #define PRODUCT_NAME			"ioq3"
-  #define BASEGAME			"baseq3"
-  #define CLIENT_WINDOW_TITLE     	"ioquake3"
-  #define CLIENT_WINDOW_MIN_TITLE 	"ioq3"
-  #define GAMENAME_FOR_MASTER		"Quake3Arena"
-#endif
+#define PRODUCT_NAME			"ioq3"
+#define BASEGAME			"baseq3"
+#define CLIENT_WINDOW_TITLE     	"ioquake3"
+#define CLIENT_WINDOW_MIN_TITLE 	"ioq3"
+#define GAMENAME_FOR_MASTER		"Quake3Arena"
 
 #ifdef _MSC_VER
   #define PRODUCT_VERSION "1.35"
@@ -165,9 +157,9 @@
 #define PAD(x,y) (((x)+(y)-1) & ~((y)-1))
 
 #ifdef __GNUC__
-#define ALIGN(x) __attribute__((aligned(x)))
+#define QALIGN(x) __attribute__((aligned(x)))
 #else
-#define ALIGN(x)
+#define QALIGN(x)
 #endif
 
 #ifndef NULL
@@ -417,6 +409,16 @@
 #define Q_fabs __fabsf
 #endif
 
+#elif idarm
+static ID_INLINE float Q_rsqrt(float number)
+{
+	return 1.0 / sqrtf(number);
+}
+
+static ID_INLINE float Q_fabs(float x)
+{
+	return fabsf(x);
+}
 #else
 float Q_fabs( float f );
 float Q_rsqrt( float f );		// reciprocal square root
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./qcommon/vm.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/vm.c
--- ./qcommon/vm.c	2012-05-25 15:53:12.245178835 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/qcommon/vm.c	2012-05-25 14:17:13.009231563 +0300
@@ -70,9 +70,9 @@
 ==============
 */
 void VM_Init( void ) {
-	Cvar_Get( "vm_cgame", "2", CVAR_ARCHIVE );	// !@# SHIP WITH SET TO 2
-	Cvar_Get( "vm_game", "2", CVAR_ARCHIVE );	// !@# SHIP WITH SET TO 2
-	Cvar_Get( "vm_ui", "2", CVAR_ARCHIVE );		// !@# SHIP WITH SET TO 2
+	Cvar_Get( "vm_cgame", "0", CVAR_ARCHIVE );	// !@# SHIP WITH SET TO 2
+	Cvar_Get( "vm_game", "0", CVAR_ARCHIVE );	// !@# SHIP WITH SET TO 2
+	Cvar_Get( "vm_ui", "0", CVAR_ARCHIVE );		// !@# SHIP WITH SET TO 2
 
 	Cmd_AddCommand ("vmprofile", VM_VmProfile_f );
 	Cmd_AddCommand ("vminfo", VM_VmInfo_f );
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/qgl.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/qgl.h
--- ./renderer/qgl.h	2012-05-25 15:50:27.621180342 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/qgl.h	2012-05-25 14:17:11.949231573 +0300
@@ -26,355 +26,133 @@
 #ifndef __QGL_H__
 #define __QGL_H__
 
-#ifdef USE_LOCAL_HEADERS
-#	include "SDL_opengl.h"
+#if defined( __LINT__ )
+
+#include <GL/gl.h>
+
+#elif defined( _WIN32 )
+
+#pragma warning (disable: 4201)
+#pragma warning (disable: 4214)
+#pragma warning (disable: 4514)
+#pragma warning (disable: 4032)
+#pragma warning (disable: 4201)
+#pragma warning (disable: 4214)
+#include <windows.h>
+#include <gl/gl.h>
+
+#elif defined(MACOS_X)
+
+#include "macosx_glimp.h"
+
+#elif defined( __linux__ )
+
+#include <GLES/gl.h>
+
+#include "../android/android_glimp.h"
+
+#elif defined( __FreeBSD__ ) // rb010123
+
+#include <GL/gl.h>
+#include <GL/glx.h>
+#if defined(__FX__)
+#include <GL/fxmesa.h>
+#endif
+
 #else
-#	include <SDL_opengl.h>
+
+#include <gl.h>
+
 #endif
 
-extern void (APIENTRYP qglActiveTextureARB) (GLenum texture);
-extern void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
-extern void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
+#ifndef APIENTRY
+#define APIENTRY
+#endif
+#ifndef WINAPI
+#define WINAPI
+#endif
+
+
+//===========================================================================
+
+/*
+** multitexture extension definitions
+*/
+#define GL_ACTIVE_TEXTURE_ARB               0x84E0
+#define GL_CLIENT_ACTIVE_TEXTURE_ARB        0x84E1
+#define GL_MAX_ACTIVE_TEXTURES_ARB          0x84E2
+
+#define GL_TEXTURE0_ARB                     0x84C0
+#define GL_TEXTURE1_ARB                     0x84C1
+#define GL_TEXTURE2_ARB                     0x84C2
+#define GL_TEXTURE3_ARB                     0x84C3
+
+// NOTE: some Linux platforms would need those prototypes
+#if defined(MACOS_X)
+typedef void (APIENTRY * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
+typedef void (APIENTRY * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRY * PFNGLACTIVETEXTUREARBPROC) (GLenum target);
+typedef void (APIENTRY * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum target);
+#endif
+
+// TTimo - VC7 / XP ?
+#ifdef WIN32
+typedef void (APIENTRY * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
+typedef void (APIENTRY * PFNGLACTIVETEXTUREARBPROC) (GLenum target);
+typedef void (APIENTRY * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum target);
+#endif
+
+/*
+** extension constants
+*/
+
+
+// S3TC compression constants
+#define GL_RGB_S3TC							0x83A0
+#define GL_RGB4_S3TC						0x83A1
+
+
+// extensions will be function pointers on all platforms
 
-extern void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
-extern void (APIENTRYP qglUnlockArraysEXT) (void);
+extern	void ( APIENTRY * qglMultiTexCoord2fARB )( GLenum texture, GLfloat s, GLfloat t );
+extern	void ( APIENTRY * qglActiveTextureARB )( GLenum texture );
+extern	void ( APIENTRY * qglClientActiveTextureARB )( GLenum texture );
 
+extern	void ( APIENTRY * qglLockArraysEXT) (GLint, GLint);
+extern	void ( APIENTRY * qglUnlockArraysEXT) (void);
 
 //===========================================================================
 
-#define qglAccum glAccum
-#define qglAlphaFunc glAlphaFunc
-#define qglAreTexturesResident glAreTexturesResident
-#define qglArrayElement glArrayElement
-#define qglBegin glBegin
-#define qglBindTexture glBindTexture
-#define qglBitmap glBitmap
-#define qglBlendFunc glBlendFunc
-#define qglCallList glCallList
-#define qglCallLists glCallLists
-#define qglClear glClear
-#define qglClearAccum glClearAccum
-#define qglClearColor glClearColor
-#define qglClearDepth glClearDepth
-#define qglClearIndex glClearIndex
-#define qglClearStencil glClearStencil
-#define qglClipPlane glClipPlane
-#define qglColor3b glColor3b
-#define qglColor3bv glColor3bv
-#define qglColor3d glColor3d
-#define qglColor3dv glColor3dv
-#define qglColor3f glColor3f
-#define qglColor3fv glColor3fv
-#define qglColor3i glColor3i
-#define qglColor3iv glColor3iv
-#define qglColor3s glColor3s
-#define qglColor3sv glColor3sv
-#define qglColor3ub glColor3ub
-#define qglColor3ubv glColor3ubv
-#define qglColor3ui glColor3ui
-#define qglColor3uiv glColor3uiv
-#define qglColor3us glColor3us
-#define qglColor3usv glColor3usv
-#define qglColor4b glColor4b
-#define qglColor4bv glColor4bv
-#define qglColor4d glColor4d
-#define qglColor4dv glColor4dv
-#define qglColor4f glColor4f
-#define qglColor4fv glColor4fv
-#define qglColor4i glColor4i
-#define qglColor4iv glColor4iv
-#define qglColor4s glColor4s
-#define qglColor4sv glColor4sv
-#define qglColor4ub glColor4ub
-#define qglColor4ubv glColor4ubv
-#define qglColor4ui glColor4ui
-#define qglColor4uiv glColor4uiv
-#define qglColor4us glColor4us
-#define qglColor4usv glColor4usv
-#define qglColorMask glColorMask
-#define qglColorMaterial glColorMaterial
-#define qglColorPointer glColorPointer
-#define qglCopyPixels glCopyPixels
-#define qglCopyTexImage1D glCopyTexImage1D
-#define qglCopyTexImage2D glCopyTexImage2D
-#define qglCopyTexSubImage1D glCopyTexSubImage1D
-#define qglCopyTexSubImage2D glCopyTexSubImage2D
-#define qglCullFace glCullFace
-#define qglDeleteLists glDeleteLists
-#define qglDeleteTextures glDeleteTextures
-#define qglDepthFunc glDepthFunc
-#define qglDepthMask glDepthMask
-#define qglDepthRange glDepthRange
-#define qglDisable glDisable
-#define qglDisableClientState glDisableClientState
-#define qglDrawArrays glDrawArrays
-#define qglDrawBuffer glDrawBuffer
-#define qglDrawElements glDrawElements
-#define qglDrawPixels glDrawPixels
-#define qglEdgeFlag glEdgeFlag
-#define qglEdgeFlagPointer glEdgeFlagPointer
-#define qglEdgeFlagv glEdgeFlagv
-#define qglEnable glEnable
-#define qglEnableClientState glEnableClientState
-#define qglEnd glEnd
-#define qglEndList glEndList
-#define qglEvalCoord1d glEvalCoord1d
-#define qglEvalCoord1dv glEvalCoord1dv
-#define qglEvalCoord1f glEvalCoord1f
-#define qglEvalCoord1fv glEvalCoord1fv
-#define qglEvalCoord2d glEvalCoord2d
-#define qglEvalCoord2dv glEvalCoord2dv
-#define qglEvalCoord2f glEvalCoord2f
-#define qglEvalCoord2fv glEvalCoord2fv
-#define qglEvalMesh1 glEvalMesh1
-#define qglEvalMesh2 glEvalMesh2
-#define qglEvalPoint1 glEvalPoint1
-#define qglEvalPoint2 glEvalPoint2
-#define qglFeedbackBuffer glFeedbackBuffer
-#define qglFinish glFinish
-#define qglFlush glFlush
-#define qglFogf glFogf
-#define qglFogfv glFogfv
-#define qglFogi glFogi
-#define qglFogiv glFogiv
-#define qglFrontFace glFrontFace
-#define qglFrustum glFrustum
-#define qglGenLists glGenLists
-#define qglGenTextures glGenTextures
-#define qglGetBooleanv glGetBooleanv
-#define qglGetClipPlane glGetClipPlane
-#define qglGetDoublev glGetDoublev
-#define qglGetError glGetError
-#define qglGetFloatv glGetFloatv
-#define qglGetIntegerv glGetIntegerv
-#define qglGetLightfv glGetLightfv
-#define qglGetLightiv glGetLightiv
-#define qglGetMapdv glGetMapdv
-#define qglGetMapfv glGetMapfv
-#define qglGetMapiv glGetMapiv
-#define qglGetMaterialfv glGetMaterialfv
-#define qglGetMaterialiv glGetMaterialiv
-#define qglGetPixelMapfv glGetPixelMapfv
-#define qglGetPixelMapuiv glGetPixelMapuiv
-#define qglGetPixelMapusv glGetPixelMapusv
-#define qglGetPointerv glGetPointerv
-#define qglGetPolygonStipple glGetPolygonStipple
-#define qglGetString glGetString
-#define qglGetTexGendv glGetTexGendv
-#define qglGetTexGenfv glGetTexGenfv
-#define qglGetTexGeniv glGetTexGeniv
-#define qglGetTexImage glGetTexImage
-#define qglGetTexLevelParameterfv glGetTexLevelParameterfv
-#define qglGetTexLevelParameteriv glGetTexLevelParameteriv
-#define qglGetTexParameterfv glGetTexParameterfv
-#define qglGetTexParameteriv glGetTexParameteriv
-#define qglHint glHint
-#define qglIndexMask glIndexMask
-#define qglIndexPointer glIndexPointer
-#define qglIndexd glIndexd
-#define qglIndexdv glIndexdv
-#define qglIndexf glIndexf
-#define qglIndexfv glIndexfv
-#define qglIndexi glIndexi
-#define qglIndexiv glIndexiv
-#define qglIndexs glIndexs
-#define qglIndexsv glIndexsv
-#define qglIndexub glIndexub
-#define qglIndexubv glIndexubv
-#define qglInitNames glInitNames
-#define qglInterleavedArrays glInterleavedArrays
-#define qglIsEnabled glIsEnabled
-#define qglIsList glIsList
-#define qglIsTexture glIsTexture
-#define qglLightModelf glLightModelf
-#define qglLightModelfv glLightModelfv
-#define qglLightModeli glLightModeli
-#define qglLightModeliv glLightModeliv
-#define qglLightf glLightf
-#define qglLightfv glLightfv
-#define qglLighti glLighti
-#define qglLightiv glLightiv
-#define qglLineStipple glLineStipple
-#define qglLineWidth glLineWidth
-#define qglListBase glListBase
-#define qglLoadIdentity glLoadIdentity
-#define qglLoadMatrixd glLoadMatrixd
-#define qglLoadMatrixf glLoadMatrixf
-#define qglLoadName glLoadName
-#define qglLogicOp glLogicOp
-#define qglMap1d glMap1d
-#define qglMap1f glMap1f
-#define qglMap2d glMap2d
-#define qglMap2f glMap2f
-#define qglMapGrid1d glMapGrid1d
-#define qglMapGrid1f glMapGrid1f
-#define qglMapGrid2d glMapGrid2d
-#define qglMapGrid2f glMapGrid2f
-#define qglMaterialf glMaterialf
-#define qglMaterialfv glMaterialfv
-#define qglMateriali glMateriali
-#define qglMaterialiv glMaterialiv
-#define qglMatrixMode glMatrixMode
-#define qglMultMatrixd glMultMatrixd
-#define qglMultMatrixf glMultMatrixf
-#define qglNewList glNewList
-#define qglNormal3b glNormal3b
-#define qglNormal3bv glNormal3bv
-#define qglNormal3d glNormal3d
-#define qglNormal3dv glNormal3dv
-#define qglNormal3f glNormal3f
-#define qglNormal3fv glNormal3fv
-#define qglNormal3i glNormal3i
-#define qglNormal3iv glNormal3iv
-#define qglNormal3s glNormal3s
-#define qglNormal3sv glNormal3sv
-#define qglNormalPointer glNormalPointer
-#define qglOrtho glOrtho
-#define qglPassThrough glPassThrough
-#define qglPixelMapfv glPixelMapfv
-#define qglPixelMapuiv glPixelMapuiv
-#define qglPixelMapusv glPixelMapusv
-#define qglPixelStoref glPixelStoref
-#define qglPixelStorei glPixelStorei
-#define qglPixelTransferf glPixelTransferf
-#define qglPixelTransferi glPixelTransferi
-#define qglPixelZoom glPixelZoom
-#define qglPointSize glPointSize
-#define qglPolygonMode glPolygonMode
-#define qglPolygonOffset glPolygonOffset
-#define qglPolygonStipple glPolygonStipple
-#define qglPopAttrib glPopAttrib
-#define qglPopClientAttrib glPopClientAttrib
-#define qglPopMatrix glPopMatrix
-#define qglPopName glPopName
-#define qglPrioritizeTextures glPrioritizeTextures
-#define qglPushAttrib glPushAttrib
-#define qglPushClientAttrib glPushClientAttrib
-#define qglPushMatrix glPushMatrix
-#define qglPushName glPushName
-#define qglRasterPos2d glRasterPos2d
-#define qglRasterPos2dv glRasterPos2dv
-#define qglRasterPos2f glRasterPos2f
-#define qglRasterPos2fv glRasterPos2fv
-#define qglRasterPos2i glRasterPos2i
-#define qglRasterPos2iv glRasterPos2iv
-#define qglRasterPos2s glRasterPos2s
-#define qglRasterPos2sv glRasterPos2sv
-#define qglRasterPos3d glRasterPos3d
-#define qglRasterPos3dv glRasterPos3dv
-#define qglRasterPos3f glRasterPos3f
-#define qglRasterPos3fv glRasterPos3fv
-#define qglRasterPos3i glRasterPos3i
-#define qglRasterPos3iv glRasterPos3iv
-#define qglRasterPos3s glRasterPos3s
-#define qglRasterPos3sv glRasterPos3sv
-#define qglRasterPos4d glRasterPos4d
-#define qglRasterPos4dv glRasterPos4dv
-#define qglRasterPos4f glRasterPos4f
-#define qglRasterPos4fv glRasterPos4fv
-#define qglRasterPos4i glRasterPos4i
-#define qglRasterPos4iv glRasterPos4iv
-#define qglRasterPos4s glRasterPos4s
-#define qglRasterPos4sv glRasterPos4sv
-#define qglReadBuffer glReadBuffer
-#define qglReadPixels glReadPixels
-#define qglRectd glRectd
-#define qglRectdv glRectdv
-#define qglRectf glRectf
-#define qglRectfv glRectfv
-#define qglRecti glRecti
-#define qglRectiv glRectiv
-#define qglRects glRects
-#define qglRectsv glRectsv
-#define qglRenderMode glRenderMode
-#define qglRotated glRotated
-#define qglRotatef glRotatef
-#define qglScaled glScaled
-#define qglScalef glScalef
-#define qglScissor glScissor
-#define qglSelectBuffer glSelectBuffer
-#define qglShadeModel glShadeModel
-#define qglStencilFunc glStencilFunc
-#define qglStencilMask glStencilMask
-#define qglStencilOp glStencilOp
-#define qglTexCoord1d glTexCoord1d
-#define qglTexCoord1dv glTexCoord1dv
-#define qglTexCoord1f glTexCoord1f
-#define qglTexCoord1fv glTexCoord1fv
-#define qglTexCoord1i glTexCoord1i
-#define qglTexCoord1iv glTexCoord1iv
-#define qglTexCoord1s glTexCoord1s
-#define qglTexCoord1sv glTexCoord1sv
-#define qglTexCoord2d glTexCoord2d
-#define qglTexCoord2dv glTexCoord2dv
-#define qglTexCoord2f glTexCoord2f
-#define qglTexCoord2fv glTexCoord2fv
-#define qglTexCoord2i glTexCoord2i
-#define qglTexCoord2iv glTexCoord2iv
-#define qglTexCoord2s glTexCoord2s
-#define qglTexCoord2sv glTexCoord2sv
-#define qglTexCoord3d glTexCoord3d
-#define qglTexCoord3dv glTexCoord3dv
-#define qglTexCoord3f glTexCoord3f
-#define qglTexCoord3fv glTexCoord3fv
-#define qglTexCoord3i glTexCoord3i
-#define qglTexCoord3iv glTexCoord3iv
-#define qglTexCoord3s glTexCoord3s
-#define qglTexCoord3sv glTexCoord3sv
-#define qglTexCoord4d glTexCoord4d
-#define qglTexCoord4dv glTexCoord4dv
-#define qglTexCoord4f glTexCoord4f
-#define qglTexCoord4fv glTexCoord4fv
-#define qglTexCoord4i glTexCoord4i
-#define qglTexCoord4iv glTexCoord4iv
-#define qglTexCoord4s glTexCoord4s
-#define qglTexCoord4sv glTexCoord4sv
-#define qglTexCoordPointer glTexCoordPointer
-#define qglTexEnvf glTexEnvf
-#define qglTexEnvfv glTexEnvfv
-#define qglTexEnvi glTexEnvi
-#define qglTexEnviv glTexEnviv
-#define qglTexGend glTexGend
-#define qglTexGendv glTexGendv
-#define qglTexGenf glTexGenf
-#define qglTexGenfv glTexGenfv
-#define qglTexGeni glTexGeni
-#define qglTexGeniv glTexGeniv
-#define qglTexImage1D glTexImage1D
-#define qglTexImage2D glTexImage2D
-#define qglTexParameterf glTexParameterf
-#define qglTexParameterfv glTexParameterfv
-#define qglTexParameteri glTexParameteri
-#define qglTexParameteriv glTexParameteriv
-#define qglTexSubImage1D glTexSubImage1D
-#define qglTexSubImage2D glTexSubImage2D
-#define qglTranslated glTranslated
-#define qglTranslatef glTranslatef
-#define qglVertex2d glVertex2d
-#define qglVertex2dv glVertex2dv
-#define qglVertex2f glVertex2f
-#define qglVertex2fv glVertex2fv
-#define qglVertex2i glVertex2i
-#define qglVertex2iv glVertex2iv
-#define qglVertex2s glVertex2s
-#define qglVertex2sv glVertex2sv
-#define qglVertex3d glVertex3d
-#define qglVertex3dv glVertex3dv
-#define qglVertex3f glVertex3f
-#define qglVertex3fv glVertex3fv
-#define qglVertex3i glVertex3i
-#define qglVertex3iv glVertex3iv
-#define qglVertex3s glVertex3s
-#define qglVertex3sv glVertex3sv
-#define qglVertex4d glVertex4d
-#define qglVertex4dv glVertex4dv
-#define qglVertex4f glVertex4f
-#define qglVertex4fv glVertex4fv
-#define qglVertex4i glVertex4i
-#define qglVertex4iv glVertex4iv
-#define qglVertex4s glVertex4s
-#define qglVertex4sv glVertex4sv
-#define qglVertexPointer glVertexPointer
-#define qglViewport glViewport
+#include "../egl/qgl.h"
 
 #endif
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_backend.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_backend.c
--- ./renderer/tr_backend.c	2012-05-25 15:51:02.721180019 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_backend.c	2012-05-25 14:17:11.953231573 +0300
@@ -327,6 +327,7 @@
 	//
 	// fill/line mode
 	//
+#if !defined(NOKIA)
 	if ( diff & GLS_POLYMODE_LINE )
 	{
 		if ( stateBits & GLS_POLYMODE_LINE )
@@ -338,6 +339,7 @@
 			qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
 		}
 	}
+#endif
 
 	//
 	// depthtest
@@ -488,7 +490,7 @@
 	// clip to the plane of the portal
 	if ( backEnd.viewParms.isPortal ) {
 		float	plane[4];
-		double	plane2[4];
+		float	plane2[4];
 
 		plane[0] = backEnd.viewParms.portalPlane.normal[0];
 		plane[1] = backEnd.viewParms.portalPlane.normal[1];
@@ -501,7 +503,7 @@
 		plane2[3] = DotProduct (plane, backEnd.viewParms.or.origin) - plane[3];
 
 		qglLoadMatrixf( s_flipMatrix );
-		qglClipPlane (GL_CLIP_PLANE0, plane2);
+		qglClipPlanef (GL_CLIP_PLANE0, plane2);
 		qglEnable (GL_CLIP_PLANE0);
 	} else {
 		qglDisable (GL_CLIP_PLANE0);
@@ -644,7 +646,7 @@
 					}
 
 					if(!oldDepthRange)
-						qglDepthRange (0, 0.3);
+						qglDepthRangef (0, 0.3);
 				}
 				else
 				{
@@ -655,7 +657,7 @@
 						qglMatrixMode(GL_MODELVIEW);
 					}
 
-					qglDepthRange (0, 1);
+					qglDepthRangef (0, 1);
 				}
 
 				oldDepthRange = depthRange;
@@ -679,7 +681,7 @@
 	// go back to the world modelview matrix
 	qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
 	if ( depthRange ) {
-		qglDepthRange (0, 1);
+		qglDepthRangef (0, 1);
 	}
 
 #if 0
@@ -715,7 +717,7 @@
 	qglScissor( 0, 0, glConfig.vidWidth, glConfig.vidHeight );
 	qglMatrixMode(GL_PROJECTION);
     qglLoadIdentity ();
-	qglOrtho (0, glConfig.vidWidth, glConfig.vidHeight, 0, 0, 1);
+	qglOrthof (0, glConfig.vidWidth, glConfig.vidHeight, 0, 0, 1);
 	qglMatrixMode(GL_MODELVIEW);
     qglLoadIdentity ();
 
@@ -744,6 +746,9 @@
 void RE_StretchRaw (int x, int y, int w, int h, int cols, int rows, const byte *data, int client, qboolean dirty) {
 	int			i, j;
 	int			start, end;
+	vec2_t texcoords[4];
+	vec2_t verts[4];
+	glIndex_t indicies[6] = { 0, 1, 2, 0, 3, 2 };
 
 	if ( !tr.registered ) {
 		return;
@@ -773,7 +778,7 @@
 	if ( cols != tr.scratchImage[client]->width || rows != tr.scratchImage[client]->height ) {
 		tr.scratchImage[client]->width = tr.scratchImage[client]->uploadWidth = cols;
 		tr.scratchImage[client]->height = tr.scratchImage[client]->uploadHeight = rows;
-		qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB8, cols, rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, data );
+		qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, cols, rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, data );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
@@ -793,18 +798,23 @@
 
 	RB_SetGL2D();
 
-	qglColor3f( tr.identityLight, tr.identityLight, tr.identityLight );
+	glColor4f( tr.identityLight, tr.identityLight, tr.identityLight, 1.0f );
 
-	qglBegin (GL_QUADS);
-	qglTexCoord2f ( 0.5f / cols,  0.5f / rows );
-	qglVertex2f (x, y);
-	qglTexCoord2f ( ( cols - 0.5f ) / cols ,  0.5f / rows );
-	qglVertex2f (x+w, y);
-	qglTexCoord2f ( ( cols - 0.5f ) / cols, ( rows - 0.5f ) / rows );
-	qglVertex2f (x+w, y+h);
-	qglTexCoord2f ( 0.5f / cols, ( rows - 0.5f ) / rows );
-	qglVertex2f (x, y+h);
-	qglEnd ();
+	verts[0][0] = x;  verts[0][1] = y;
+	verts[1][0] = x+w;  verts[1][1] = y;
+	verts[2][0] = x+w;  verts[2][1] = y+h;
+	verts[3][0] = x;  verts[3][1] = y+h;
+	
+	texcoords[0][0] = 0.5f/cols;      texcoords[0][1] = 0.5f/rows;
+	texcoords[1][0] = (cols-0.5f)/cols;   texcoords[1][1] = 0.5f/rows;
+	texcoords[2][0] = (cols-0.5f)/cols;   texcoords[2][1] = (rows-0.5f)/rows;
+	texcoords[3][0] = 0.5f/cols;      texcoords[3][1] = (rows-0.5f)/rows;
+	
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+	qglTexCoordPointer( 2, GL_FLOAT, 0, texcoords );
+	qglVertexPointer  ( 2, GL_FLOAT, 0, verts );
+	qglDrawElements( GL_TRIANGLE_STRIP, 6, GL_INDEX_TYPE, indicies );
+	qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
 }
 
 void RE_UploadCinematic (int w, int h, int cols, int rows, const byte *data, int client, qboolean dirty) {
@@ -815,7 +825,7 @@
 	if ( cols != tr.scratchImage[client]->width || rows != tr.scratchImage[client]->height ) {
 		tr.scratchImage[client]->width = tr.scratchImage[client]->uploadWidth = cols;
 		tr.scratchImage[client]->height = tr.scratchImage[client]->uploadHeight = rows;
-		qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB8, cols, rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, data );
+		qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, cols, rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, data );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
@@ -987,6 +997,9 @@
 	image_t	*image;
 	float	x, y, w, h;
 	int		start, end;
+	vec2_t texcoords[4] = { {0.0f, 0.0f}, {1.0f, 0.0f}, {1.0f, 1.0f}, {0.0f, 1.0f} };
+	vec2_t verts[4];
+	glIndex_t indicies[6] = { 0, 1, 2, 0, 3, 2 };
 
 	if ( !backEnd.projection2D ) {
 		RB_SetGL2D();
@@ -998,6 +1011,8 @@
 
 	start = ri.Milliseconds();
 
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+
 	for ( i=0 ; i<tr.numImages ; i++ ) {
 		image = tr.images[i];
 
@@ -1012,19 +1027,17 @@
 			h *= image->uploadHeight / 512.0f;
 		}
 
-		GL_Bind( image );
-		qglBegin (GL_QUADS);
-		qglTexCoord2f( 0, 0 );
-		qglVertex2f( x, y );
-		qglTexCoord2f( 1, 0 );
-		qglVertex2f( x + w, y );
-		qglTexCoord2f( 1, 1 );
-		qglVertex2f( x + w, y + h );
-		qglTexCoord2f( 0, 1 );
-		qglVertex2f( x, y + h );
-		qglEnd();
+		verts[0][0] = x;  verts[0][1] = y;
+		verts[1][0] = x+w;  verts[1][1] = y;
+		verts[2][0] = x+w;  verts[2][1] = y+h;
+		verts[3][0] = x;  verts[3][1] = y+h;
+
+		qglTexCoordPointer( 2, GL_FLOAT, 0, texcoords );
+		qglVertexPointer  ( 2, GL_FLOAT, 0, verts );
+		qglDrawElements( GL_TRIANGLE_STRIP, 6, GL_INDEX_TYPE, indicies );
 	}
 
+	qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
 	qglFinish();
 
 	end = ri.Milliseconds();
@@ -1090,6 +1103,7 @@
 
 	cmd = (const swapBuffersCommand_t *)data;
 
+#if !defined(NOKIA)
 	// we measure overdraw by reading back the stencil buffer and
 	// counting up the number of increments that have happened
 	if ( r_measureOverdraw->integer ) {
@@ -1107,6 +1121,7 @@
 		backEnd.pc.c_overDraw += sum;
 		ri.Hunk_FreeTempMemory( stencilReadback );
 	}
+#endif
 
 
 	if ( !glState.finishCalled ) {
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_cmds.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_cmds.c
--- ./renderer/tr_cmds.c	2012-05-25 15:53:12.105178836 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_cmds.c	2012-05-25 14:17:11.945231573 +0300
@@ -413,6 +413,7 @@
 			ri.Error(ERR_FATAL, "RE_BeginFrame() - glGetError() failed (0x%x)!\n", err);
 	}
 
+#if !defined(NOKIA)
 	if (glConfig.stereoEnabled) {
 		if( !(cmd = R_GetCommandBuffer(sizeof(*cmd))) )
 			return;
@@ -428,6 +429,7 @@
 		}
 	}
 	else
+#endif
 	{
 		if(r_anaglyphMode->integer)
 		{
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_flares.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_flares.c
--- ./renderer/tr_flares.c	2012-05-25 15:53:12.105178836 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_flares.c	2012-05-25 14:17:11.941231573 +0300
@@ -253,6 +253,8 @@
 ===============================================================================
 */
 
+#if !defined(NOKIA)
+
 /*
 ==================
 RB_TestFlare
@@ -510,7 +512,7 @@
 	qglMatrixMode( GL_PROJECTION );
 	qglPushMatrix();
     qglLoadIdentity();
-	qglOrtho( backEnd.viewParms.viewportX, backEnd.viewParms.viewportX + backEnd.viewParms.viewportWidth,
+	qglOrthof( backEnd.viewParms.viewportX, backEnd.viewParms.viewportX + backEnd.viewParms.viewportWidth,
 			  backEnd.viewParms.viewportY, backEnd.viewParms.viewportY + backEnd.viewParms.viewportHeight,
 			  -99999, 99999 );
 
@@ -527,3 +529,8 @@
 	qglPopMatrix();
 }
 
+#else
+void RB_RenderFlares(void)
+{
+}
+#endif
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_image.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_image.c
--- ./renderer/tr_image.c	2012-05-25 15:53:12.105178836 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_image.c	2012-05-25 14:17:11.949231573 +0300
@@ -175,22 +175,28 @@
 		case 4:
 			ri.Printf( PRINT_ALL, "RGBA " );
 			break;
+#if !defined(NOKIA)
 		case GL_RGBA8:
 			ri.Printf( PRINT_ALL, "RGBA8" );
 			break;
 		case GL_RGB8:
 			ri.Printf( PRINT_ALL, "RGB8" );
 			break;
+#endif
 		case GL_RGB4_S3TC:
+#if !defined(NOKIA)
 		case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+#endif
 			ri.Printf( PRINT_ALL, "S3TC " );
 			break;
+#if !defined(NOKIA)
 		case GL_RGBA4:
 			ri.Printf( PRINT_ALL, "RGBA4" );
 			break;
 		case GL_RGB5:
 			ri.Printf( PRINT_ALL, "RGB5 " );
 			break;
+#endif
 		default:
 			ri.Printf( PRINT_ALL, "???? " );
 		}
@@ -560,6 +566,7 @@
 	scan = ((byte *)data);
 	samples = 3;
 
+#if !defined(NOKIA)
 	if(lightMap)
 	{
 		if(r_greyscale->integer)
@@ -568,6 +575,9 @@
 			internalFormat = GL_RGB;
 	}
 	else
+#else
+	if(!lightMap)
+#endif
 	{
 		for ( i = 0; i < c; i++ )
 		{
@@ -592,6 +602,7 @@
 		// select proper internal format
 		if ( samples == 3 )
 		{
+#if !defined(NOKIA)
 			if(r_greyscale->integer)
 			{
 				if(r_texturebits->integer == 16)
@@ -624,9 +635,13 @@
 					internalFormat = GL_RGB;
 				}
 			}
+#else
+			internalFormat = GL_RGBA;
+#endif
 		}
 		else if ( samples == 4 )
 		{
+#if !defined(NOKIA)
 			if(r_greyscale->integer)
 			{
 				if(r_texturebits->integer == 16)
@@ -651,6 +666,9 @@
 					internalFormat = GL_RGBA;
 				}
 			}
+#else
+			internalFormat = GL_RGBA;
+#endif
 		}
 	}
 
@@ -720,17 +738,21 @@
 
 	if (mipmap)
 	{
+#if !defined(NOKIA)
 		if ( textureFilterAnisotropic )
 			qglTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT,
 					(GLint)Com_Clamp( 1, maxAnisotropy, r_ext_max_anisotropy->integer ) );
+#endif
 
 		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
 		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
 	}
 	else
 	{
+#if !defined(NOKIA)
 		if ( textureFilterAnisotropic )
 			qglTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1 );
+#endif
 
 		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
 		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
@@ -1074,7 +1096,9 @@
 	byte	*data;
 	float	g;
 	float	d;
+#if !defined(NOKIA)
 	float	borderColor[4];
+#endif
 
 	data = ri.Hunk_AllocateTempMemory( FOG_S * FOG_T * 4 );
 
@@ -1097,12 +1121,14 @@
 	tr.fogImage = R_CreateImage("*fog", (byte *)data, FOG_S, FOG_T, qfalse, qfalse, GL_CLAMP_TO_EDGE );
 	ri.Hunk_FreeTempMemory( data );
 
+#if !defined(NOKIA)
 	borderColor[0] = 1.0;
 	borderColor[1] = 1.0;
 	borderColor[2] = 1.0;
 	borderColor[3] = 1;
 
 	qglTexParameterfv( GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor );
+#endif
 }
 
 /*
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_init.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_init.c
--- ./renderer/tr_init.c	2012-05-25 15:54:55.305177892 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_init.c	2012-05-25 14:17:11.941231573 +0300
@@ -159,6 +159,13 @@
 cvar_t	*r_maxpolyverts;
 int		max_polyverts;
 
+void (APIENTRY * qglMultiTexCoord2fARB) (GLenum texture, GLfloat s, GLfloat t);
+void (APIENTRY * qglActiveTextureARB) (GLenum texture);
+void (APIENTRY * qglClientActiveTextureARB) (GLenum texture);
+
+void (APIENTRY * qglLockArraysEXT) (GLint, GLint);
+void (APIENTRY * qglUnlockArraysEXT) (void);
+
 /*
 ** InitOpenGL
 **
@@ -735,11 +742,11 @@
 */
 void GL_SetDefaultState( void )
 {
-	qglClearDepth( 1.0f );
+	qglClearDepthf( 1.0f );
 
 	qglCullFace(GL_FRONT);
 
-	qglColor4f (1,1,1,1);
+	glColor4f (1,1,1,1);
 
 	// initialize downstream texture unit if we're running
 	// in a multitexture environment
@@ -767,7 +774,9 @@
 	//
 	glState.glStateBits = GLS_DEPTHTEST_DISABLE | GLS_DEPTHMASK_TRUE;
 
+#if !defined(NOKIA)
 	qglPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
+#endif
 	qglDepthMask( GL_TRUE );
 	qglDisable( GL_DEPTH_TEST );
 	qglEnable( GL_SCISSOR_TEST );
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_local.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_local.h
--- ./renderer/tr_local.h	2012-05-25 15:53:12.109178836 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_local.h	2012-05-25 14:17:11.941231573 +0300
@@ -30,8 +30,8 @@
 #include "tr_public.h"
 #include "qgl.h"
 
-#define GL_INDEX_TYPE		GL_UNSIGNED_INT
-typedef unsigned int glIndex_t;
+#define GL_INDEX_TYPE		GL_UNSIGNED_SHORT
+typedef unsigned short glIndex_t;
 
 // fast float to int conversion
 #if id386 && !defined(__GNUC__)
@@ -1300,16 +1300,16 @@
 
 typedef struct shaderCommands_s 
 {
-	glIndex_t	indexes[SHADER_MAX_INDEXES] ALIGN(16);
-	vec4_t		xyz[SHADER_MAX_VERTEXES] ALIGN(16);
-	vec4_t		normal[SHADER_MAX_VERTEXES] ALIGN(16);
-	vec2_t		texCoords[SHADER_MAX_VERTEXES][2] ALIGN(16);
-	color4ub_t	vertexColors[SHADER_MAX_VERTEXES] ALIGN(16);
-	int			vertexDlightBits[SHADER_MAX_VERTEXES] ALIGN(16);
+	glIndex_t	indexes[SHADER_MAX_INDEXES] QALIGN(16);
+	vec4_t		xyz[SHADER_MAX_VERTEXES] QALIGN(16);
+	vec4_t		normal[SHADER_MAX_VERTEXES] QALIGN(16);
+	vec2_t		texCoords[SHADER_MAX_VERTEXES][2] QALIGN(16);
+	color4ub_t	vertexColors[SHADER_MAX_VERTEXES] QALIGN(16);
+	int			vertexDlightBits[SHADER_MAX_VERTEXES] QALIGN(16);
 
-	stageVars_t	svars ALIGN(16);
+	stageVars_t	svars QALIGN(16);
 
-	color4ub_t	constantColor255[SHADER_MAX_VERTEXES] ALIGN(16);
+	color4ub_t	constantColor255[SHADER_MAX_VERTEXES] QALIGN(16);
 
 	shader_t	*shader;
   float   shaderTime;
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_main.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_main.c
--- ./renderer/tr_main.c	2012-05-25 15:54:55.305177892 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_main.c	2012-05-25 14:17:11.949231573 +0300
@@ -1314,6 +1314,7 @@
 ================
 */
 void R_DebugPolygon( int color, int numPoints, float *points ) {
+#if 0
 	int		i;
 
 	GL_State( GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
@@ -1329,14 +1330,15 @@
 
 	// draw wireframe outline
 	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
-	qglDepthRange( 0, 0 );
+	qglDepthRangef( 0, 0 );
 	qglColor3f( 1, 1, 1 );
 	qglBegin( GL_POLYGON );
 	for ( i = 0 ; i < numPoints ; i++ ) {
 		qglVertex3fv( points + i * 3 );
 	}
 	qglEnd();
-	qglDepthRange( 0, 1 );
+	qglDepthRangef( 0, 1 );
+#endif
 }
 
 /*
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_shade.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_shade.c
--- ./renderer/tr_shade.c	2012-05-25 15:53:12.105178836 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_shade.c	2012-05-25 14:17:11.949231573 +0300
@@ -34,127 +34,6 @@
 */
 
 /*
-================
-R_ArrayElementDiscrete
-
-This is just for OpenGL conformance testing, it should never be the fastest
-================
-*/
-static void APIENTRY R_ArrayElementDiscrete( GLint index ) {
-	qglColor4ubv( tess.svars.colors[ index ] );
-	if ( glState.currenttmu ) {
-		qglMultiTexCoord2fARB( 0, tess.svars.texcoords[ 0 ][ index ][0], tess.svars.texcoords[ 0 ][ index ][1] );
-		qglMultiTexCoord2fARB( 1, tess.svars.texcoords[ 1 ][ index ][0], tess.svars.texcoords[ 1 ][ index ][1] );
-	} else {
-		qglTexCoord2fv( tess.svars.texcoords[ 0 ][ index ] );
-	}
-	qglVertex3fv( tess.xyz[ index ] );
-}
-
-/*
-===================
-R_DrawStripElements
-
-===================
-*/
-static int		c_vertexes;		// for seeing how long our average strips are
-static int		c_begins;
-static void R_DrawStripElements( int numIndexes, const glIndex_t *indexes, void ( APIENTRY *element )(GLint) ) {
-	int i;
-	int last[3] = { -1, -1, -1 };
-	qboolean even;
-
-	c_begins++;
-
-	if ( numIndexes <= 0 ) {
-		return;
-	}
-
-	qglBegin( GL_TRIANGLE_STRIP );
-
-	// prime the strip
-	element( indexes[0] );
-	element( indexes[1] );
-	element( indexes[2] );
-	c_vertexes += 3;
-
-	last[0] = indexes[0];
-	last[1] = indexes[1];
-	last[2] = indexes[2];
-
-	even = qfalse;
-
-	for ( i = 3; i < numIndexes; i += 3 )
-	{
-		// odd numbered triangle in potential strip
-		if ( !even )
-		{
-			// check previous triangle to see if we're continuing a strip
-			if ( ( indexes[i+0] == last[2] ) && ( indexes[i+1] == last[1] ) )
-			{
-				element( indexes[i+2] );
-				c_vertexes++;
-				assert( indexes[i+2] < tess.numVertexes );
-				even = qtrue;
-			}
-			// otherwise we're done with this strip so finish it and start
-			// a new one
-			else
-			{
-				qglEnd();
-
-				qglBegin( GL_TRIANGLE_STRIP );
-				c_begins++;
-
-				element( indexes[i+0] );
-				element( indexes[i+1] );
-				element( indexes[i+2] );
-
-				c_vertexes += 3;
-
-				even = qfalse;
-			}
-		}
-		else
-		{
-			// check previous triangle to see if we're continuing a strip
-			if ( ( last[2] == indexes[i+1] ) && ( last[0] == indexes[i+0] ) )
-			{
-				element( indexes[i+2] );
-				c_vertexes++;
-
-				even = qfalse;
-			}
-			// otherwise we're done with this strip so finish it and start
-			// a new one
-			else
-			{
-				qglEnd();
-
-				qglBegin( GL_TRIANGLE_STRIP );
-				c_begins++;
-
-				element( indexes[i+0] );
-				element( indexes[i+1] );
-				element( indexes[i+2] );
-				c_vertexes += 3;
-
-				even = qfalse;
-			}
-		}
-
-		// cache the last three vertices
-		last[0] = indexes[i+0];
-		last[1] = indexes[i+1];
-		last[2] = indexes[i+2];
-	}
-
-	qglEnd();
-}
-
-
-
-/*
 ==================
 R_DrawElements
 
@@ -163,40 +42,9 @@
 without compiled vertex arrays.
 ==================
 */
-static void R_DrawElements( int numIndexes, const glIndex_t *indexes ) {
-	int		primitives;
-
-	primitives = r_primitives->integer;
-
-	// default is to use triangles if compiled vertex arrays are present
-	if ( primitives == 0 ) {
-		if ( qglLockArraysEXT ) {
-			primitives = 2;
-		} else {
-			primitives = 1;
-		}
-	}
-
-
-	if ( primitives == 2 ) {
-		qglDrawElements( GL_TRIANGLES, 
-						numIndexes,
-						GL_INDEX_TYPE,
-						indexes );
-		return;
-	}
-
-	if ( primitives == 1 ) {
-		R_DrawStripElements( numIndexes,  indexes, qglArrayElement );
-		return;
-	}
-	
-	if ( primitives == 3 ) {
-		R_DrawStripElements( numIndexes,  indexes, R_ArrayElementDiscrete );
-		return;
-	}
-
-	// anything else will cause no drawing
+static void R_DrawElements( int numIndexes, const glIndex_t* indexes )
+{
+	qglDrawElements(GL_TRIANGLES, numIndexes, GL_INDEX_TYPE, indexes);
 }
 
 
@@ -253,10 +101,10 @@
 */
 static void DrawTris (shaderCommands_t *input) {
 	GL_Bind( tr.whiteImage );
-	qglColor3f (1,1,1);
+	glColor4f (1,1,1,1);
 
 	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
-	qglDepthRange( 0, 0 );
+	qglDepthRangef( 0, 0 );
 
 	qglDisableClientState (GL_COLOR_ARRAY);
 	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
@@ -274,7 +122,7 @@
 		qglUnlockArraysEXT();
 		GLimp_LogComment( "glUnlockArraysEXT\n" );
 	}
-	qglDepthRange( 0, 1 );
+	qglDepthRangef( 0, 1 );
 }
 
 
@@ -288,21 +136,26 @@
 static void DrawNormals (shaderCommands_t *input) {
 	int		i;
 	vec3_t	temp;
+	vec3_t verts[2 * SHADER_MAX_VERTEXES];
+	glIndex_t indicies[2 * SHADER_MAX_VERTEXES];
+
+	for (i = 0; i < input->numVertexes; i++) {
+		VectorCopy(input->xyz[i], verts[i * 2]);
+		VectorMA(input->xyz[i], 2, input->normal[i], temp);
+		VectorCopy(temp, verts[(i * 2) + 1]);
+		indicies[(i * 2)] = i * 2;
+		indicies[(i * 2) + 1] = (i * 2) + 1;
+	}
 
 	GL_Bind( tr.whiteImage );
-	qglColor3f (1,1,1);
-	qglDepthRange( 0, 0 );	// never occluded
+	glColor4f (1,1,1,1);
+	qglDepthRangef( 0, 0 );	// never occluded
 	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
 
-	qglBegin (GL_LINES);
-	for (i = 0 ; i < input->numVertexes ; i++) {
-		qglVertex3fv (input->xyz[i]);
-		VectorMA (input->xyz[i], 2, input->normal[i], temp);
-		qglVertex3fv (temp);
-	}
-	qglEnd ();
+	qglVertexPointer(3, GL_FLOAT, 0, verts);
+	qglDrawElements(GL_LINES, i, GL_INDEX_TYPE, indicies);
 
-	qglDepthRange( 0, 1 );
+	qglDepthRangef( 0, 1 );
 }
 
 /*
@@ -352,11 +205,13 @@
 
 	GL_State( pStage->stateBits );
 
+#if !defined(NOKIA)
 	// this is an ugly hack to work around a GeForce driver
 	// bug with multitexture and clip planes
 	if ( backEnd.viewParms.isPortal ) {
 		qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
 	}
+#endif
 
 	//
 	// base
@@ -421,7 +276,7 @@
 	byte	clipBits[SHADER_MAX_VERTEXES];
 	float	texCoordsArray[SHADER_MAX_VERTEXES][2];
 	byte	colorArray[SHADER_MAX_VERTEXES][4];
-	unsigned	hitIndexes[SHADER_MAX_INDEXES];
+	glIndex_t	hitIndexes[SHADER_MAX_INDEXES];
 	int		numIndexes;
 	float	scale;
 	float	radius;
@@ -584,7 +439,7 @@
 	byte	clipBits[SHADER_MAX_VERTEXES];
 	float	texCoordsArray[SHADER_MAX_VERTEXES][2];
 	byte	colorArray[SHADER_MAX_VERTEXES][4];
-	unsigned	hitIndexes[SHADER_MAX_INDEXES];
+	glIndex_t	hitIndexes[SHADER_MAX_INDEXES];
 	int		numIndexes;
 	float	scale;
 	float	radius;
@@ -680,7 +535,7 @@
 		// build a list of triangles that need light
 		numIndexes = 0;
 		for ( i = 0 ; i < tess.numIndexes ; i += 3 ) {
-			int		a, b, c;
+			glIndex_t	a, b, c;
 
 			a = tess.indexes[i];
 			b = tess.indexes[i+1];
@@ -1148,6 +1003,9 @@
 
 	input = &tess;
 
+	if (!input->numVertexes)
+		return;
+
 	RB_DeformTessGeometry();
 
 	//
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_shadows.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_shadows.c
--- ./renderer/tr_shadows.c	2012-05-25 15:50:45.949180173 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_shadows.c	2012-05-25 14:17:11.941231573 +0300
@@ -124,12 +124,14 @@
 			// if it doesn't share the edge with another front facing
 			// triangle, it is a sil edge
 			if ( hit[ 1 ] == 0 ) {
-				qglBegin( GL_TRIANGLE_STRIP );
-				qglVertex3fv( tess.xyz[ i ] );
-				qglVertex3fv( tess.xyz[ i + tess.numVertexes ] );
-				qglVertex3fv( tess.xyz[ i2 ] );
-				qglVertex3fv( tess.xyz[ i2 + tess.numVertexes ] );
-				qglEnd();
+				glIndex_t indicies[4];
+				indicies[0] = i;
+				indicies[1] = i + tess.numVertexes;
+				indicies[2] = i2;
+				indicies[3] = i2 + tess.numVertexes;
+
+				qglVertexPointer(3, GL_FLOAT, 16, tess.xyz);
+				qglDrawElements(GL_TRIANGLE_STRIP, 4, GL_INDEX_TYPE, indicies);
 				c_edges++;
 			} else {
 				c_rejected++;
@@ -213,7 +215,7 @@
 	GL_Bind( tr.whiteImage );
 	qglEnable( GL_CULL_FACE );
 	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
-	qglColor3f( 0.2f, 0.2f, 0.2f );
+	glColor4f( 0.2f, 0.2f, 0.2f, 1.0f );
 
 	// don't write to the color buffer
 	qglGetBooleanv(GL_COLOR_WRITEMASK, rgba);
@@ -262,6 +264,14 @@
 =================
 */
 void RB_ShadowFinish( void ) {
+	vec3_t quad[4] = {
+		{-100.0f,  100.0f, -10.0f},
+		{ 100.0f,  100.0f, -10.0f},
+		{ 100.0f, -100.0f, -10.0f},
+		{-100.0f, -100.0f, -10.0f}
+	};
+	glIndex_t indicies[6] = { 0, 1, 2, 0, 3, 2 };
+
 	if ( r_shadows->integer != 2 ) {
 		return;
 	}
@@ -278,20 +288,16 @@
 
     qglLoadIdentity ();
 
-	qglColor3f( 0.6f, 0.6f, 0.6f );
+	glColor4f( 0.6f, 0.6f, 0.6f, 1.0f );
 	GL_State( GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO );
 
-//	qglColor3f( 1, 0, 0 );
+//	glColor4f( 1, 0, 0, 1 );
 //	GL_State( GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
 
-	qglBegin( GL_QUADS );
-	qglVertex3f( -100, 100, -10 );
-	qglVertex3f( 100, 100, -10 );
-	qglVertex3f( 100, -100, -10 );
-	qglVertex3f( -100, -100, -10 );
-	qglEnd ();
+	qglVertexPointer(3, GL_FLOAT, 0, quad);
+	qglDrawElements(GL_TRIANGLE_STRIP, 6, GL_INDEX_TYPE, indicies);
 
-	qglColor4f(1,1,1,1);
+	glColor4f(1,1,1,1);
 	qglDisable( GL_STENCIL_TEST );
 }
 
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_sky.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_sky.c
--- ./renderer/tr_sky.c	2012-05-25 15:18:40.745197799 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_sky.c	2012-05-25 14:17:11.945231573 +0300
@@ -363,25 +363,30 @@
 
 static void DrawSkySide( struct image_s *image, const int mins[2], const int maxs[2] )
 {
-	int s, t;
+	int s, t, i = 0;
+	int size;
+	glIndex_t *indicies;
+
+	size = (maxs[1] - mins[1]) * (maxs[0] - mins[0] + 1);
+	indicies = ri.Hunk_AllocateTempMemory(sizeof(glIndex_t) * size);
 
 	GL_Bind( image );
 
 	for ( t = mins[1]+HALF_SKY_SUBDIVISIONS; t < maxs[1]+HALF_SKY_SUBDIVISIONS; t++ )
 	{
-		qglBegin( GL_TRIANGLE_STRIP );
-
 		for ( s = mins[0]+HALF_SKY_SUBDIVISIONS; s <= maxs[0]+HALF_SKY_SUBDIVISIONS; s++ )
 		{
-			qglTexCoord2fv( s_skyTexCoords[t][s] );
-			qglVertex3fv( s_skyPoints[t][s] );
-
-			qglTexCoord2fv( s_skyTexCoords[t+1][s] );
-			qglVertex3fv( s_skyPoints[t+1][s] );
+			indicies[i++] = t * (SKY_SUBDIVISIONS + 1) + s;
+			indicies[i++] = (t + 1) * (SKY_SUBDIVISIONS + 1) + s;
 		}
-
-		qglEnd();
 	}
+
+	qglDisableClientState(GL_COLOR_ARRAY);
+	qglEnableClientState(GL_TEXTURE_COORD_ARRAY);
+	qglTexCoordPointer(2, GL_FLOAT, 0, s_skyTexCoords);
+	qglVertexPointer(3, GL_FLOAT, 0, s_skyPoints);
+	qglDrawElements(GL_TRIANGLE_STRIP, i, GL_INDEX_TYPE, indicies);
+	Hunk_FreeTempMemory(indicies);
 }
 
 static void DrawSkyBox( shader_t *shader )
@@ -722,7 +727,7 @@
 	VectorScale( vec2, size, vec2 );
 
 	// farthest depth range
-	qglDepthRange( 1.0, 1.0 );
+	qglDepthRangef( 1.0, 1.0 );
 
 	// FIXME: use quad stamp
 	RB_BeginSurface( tr.sunShader, tess.fogNum );
@@ -780,7 +785,7 @@
 	RB_EndSurface();
 
 	// back to normal depth range
-	qglDepthRange( 0.0, 1.0 );
+	qglDepthRangef( 0.0, 1.0 );
 }
 
 
@@ -809,14 +814,14 @@
 	// front of everything to allow developers to see how
 	// much sky is getting sucked in
 	if ( r_showsky->integer ) {
-		qglDepthRange( 0.0, 0.0 );
+		qglDepthRangef( 0.0, 0.0 );
 	} else {
-		qglDepthRange( 1.0, 1.0 );
+		qglDepthRangef( 1.0, 1.0 );
 	}
 
 	// draw the outer skybox
 	if ( tess.shader->sky.outerbox[0] && tess.shader->sky.outerbox[0] != tr.defaultImage ) {
-		qglColor3f( tr.identityLight, tr.identityLight, tr.identityLight );
+		glColor4f( tr.identityLight, tr.identityLight, tr.identityLight, 1.0f );
 		
 		qglPushMatrix ();
 		GL_State( 0 );
@@ -837,7 +842,7 @@
 
 
 	// back to normal depth range
-	qglDepthRange( 0.0, 1.0 );
+	qglDepthRangef( 0.0, 1.0 );
 
 	// note that sky was drawn so we will draw a sun later
 	backEnd.skyRenderedThisView = qtrue;
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./renderer/tr_surface.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_surface.c
--- ./renderer/tr_surface.c	2012-05-25 15:53:12.109178836 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/renderer/tr_surface.c	2012-05-25 14:17:11.945231573 +0300
@@ -291,7 +291,7 @@
 	int	i;
 	vec3_t perpvec;
 	vec3_t direction, normalized_direction;
-	vec3_t	start_points[NUM_BEAM_SEGS], end_points[NUM_BEAM_SEGS];
+	vec3_t points[NUM_BEAM_SEGS * 2];
 	vec3_t oldorigin, origin;
 
 	e = &backEnd.currentEntity->e;
@@ -317,23 +317,18 @@
 
 	for ( i = 0; i < NUM_BEAM_SEGS ; i++ )
 	{
-		RotatePointAroundVector( start_points[i], normalized_direction, perpvec, (360.0/NUM_BEAM_SEGS)*i );
-//		VectorAdd( start_points[i], origin, start_points[i] );
-		VectorAdd( start_points[i], direction, end_points[i] );
+		RotatePointAroundVector(points[i * 2], normalized_direction, perpvec, (360.0 / NUM_BEAM_SEGS) * i);
+		VectorAdd(points[i * 2], direction, points[i * 2 + 1]);
 	}
 
 	GL_Bind( tr.whiteImage );
 
 	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
 
-	qglColor3f( 1, 0, 0 );
+	glColor4f( 1, 0, 0, 1 );
 
-	qglBegin( GL_TRIANGLE_STRIP );
-	for ( i = 0; i <= NUM_BEAM_SEGS; i++ ) {
-		qglVertex3fv( start_points[ i % NUM_BEAM_SEGS] );
-		qglVertex3fv( end_points[ i % NUM_BEAM_SEGS] );
-	}
-	qglEnd();
+	qglVertexPointer(3, GL_FLOAT, 0, points);
+	qglDrawArrays(GL_TRIANGLE_STRIP, 0, NUM_BEAM_SEGS * 2);
 }
 
 //================================================================================
@@ -615,10 +610,10 @@
 {
 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
 	float	*outXyz, *outNormal;
-	float	oldXyzScale ALIGN(16);
-	float   newXyzScale ALIGN(16);
-	float	oldNormalScale ALIGN(16);
-	float newNormalScale ALIGN(16);
+	float	oldXyzScale QALIGN(16);
+	float   newXyzScale QALIGN(16);
+	float	oldNormalScale QALIGN(16);
+	float newNormalScale QALIGN(16);
 	int		vertNum;
 	unsigned lat, lng;
 	int		numVerts;
@@ -905,7 +900,8 @@
 */
 static void RB_SurfaceFace( srfSurfaceFace_t *surf ) {
 	int			i;
-	unsigned	*indices, *tessIndexes;
+	unsigned int	*indices;
+	glIndex_t	*tessIndexes;
 	float		*v;
 	float		*normal;
 	int			ndx;
@@ -1161,19 +1157,27 @@
 ===================
 */
 static void RB_SurfaceAxis( void ) {
+	byte colors[3][4] = {
+		{255, 0, 0, 255},
+		{0, 255, 0, 255},
+		{0, 0, 255, 255}
+	};
+	vec3_t verts[6] = {
+		{0.0f, 0.0f, 0.0f},
+		{16.0f, 0.0f, 0.0f},
+		{0.0f, 0.0f, 0.0f},
+		{0.0f, 16.0f, 0.0f},
+		{0.0f, 0.0f, 0.0f},
+		{0.0f, 0.0f, 16.0f}
+	};
+	glIndex_t indicies[6] = { 0, 1, 0, 2, 0, 3 };
+
 	GL_Bind( tr.whiteImage );
 	qglLineWidth( 3 );
-	qglBegin( GL_LINES );
-	qglColor3f( 1,0,0 );
-	qglVertex3f( 0,0,0 );
-	qglVertex3f( 16,0,0 );
-	qglColor3f( 0,1,0 );
-	qglVertex3f( 0,0,0 );
-	qglVertex3f( 0,16,0 );
-	qglColor3f( 0,0,1 );
-	qglVertex3f( 0,0,0 );
-	qglVertex3f( 0,0,16 );
-	qglEnd();
+	qglEnableClientState(GL_COLOR_ARRAY);
+	qglColorPointer(4, GL_UNSIGNED_BYTE, 0, colors);
+	qglVertexPointer(3, GL_FLOAT, 0, verts);
+	qglDrawElements(GL_LINES, 6, GL_INDEX_TYPE, indicies);
 	qglLineWidth( 1 );
 }
 
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./sdl/null_snddma.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/sdl/null_snddma.c
--- ./sdl/null_snddma.c	1970-01-01 03:00:00.000000000 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/sdl/null_snddma.c	2012-05-25 14:17:10.381231587 +0300
@@ -0,0 +1,60 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+
+This file is part of Quake III Arena source code.
+
+Quake III Arena source code is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Quake III Arena source code is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Quake III Arena source code; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+// snddma_null.c
+// all other sound mixing is portable
+
+#include "../qcommon/q_shared.h"
+#include "../qcommon/qcommon.h"
+
+qboolean SNDDMA_Init(void)
+{
+	return qfalse;
+}
+
+int	SNDDMA_GetDMAPos(void)
+{
+	return 0;
+}
+
+void SNDDMA_Shutdown(void)
+{
+}
+
+void SNDDMA_BeginPainting (void)
+{
+}
+
+void SNDDMA_Submit(void)
+{
+}
+
+sfxHandle_t S_RegisterSound( const char *name, qboolean compressed ) 
+{
+	return 0;
+}
+
+void S_StartLocalSound( sfxHandle_t sfxHandle, int channelNum ) {
+}
+
+void S_ClearSoundBuffer( void ) {
+}
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./sys/con_tty.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/sys/con_tty.c
--- ./sys/con_tty.c	2012-05-25 15:53:12.969178827 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/sys/con_tty.c	2012-05-25 14:17:14.617231547 +0300
@@ -30,6 +30,8 @@
 #include <fcntl.h>
 #include <sys/time.h>
 
+#include <android/log.h>
+
 /*
 =============================================================
 tty console routines
@@ -452,10 +454,13 @@
 {
 	CON_Hide( );
 
+        __android_log_print(ANDROID_LOG_DEBUG, "Quake_DEBUG", "%s", msg);
+#if 0
 	if( com_ansiColor && com_ansiColor->integer )
 		Sys_AnsiColorPrint( msg );
 	else
 		fputs( msg, stderr );
+#endif
 
 	CON_Show( );
 }
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./sys/sys_loadlib.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/sys/sys_loadlib.h
--- ./sys/sys_loadlib.h	2012-05-25 15:51:05.457179996 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/sys/sys_loadlib.h	2012-05-25 14:17:14.617231547 +0300
@@ -20,6 +20,7 @@
 ===========================================================================
 */
 
+#if !defined(NOKIA)
 #ifdef DEDICATED
 #	ifdef _WIN32
 #		include <windows.h>
@@ -47,3 +48,10 @@
 #	define Sys_LoadFunction(h,fn) SDL_LoadFunction(h,fn)
 #	define Sys_LibraryError() SDL_GetError()
 #endif
+#else
+#include <dlfcn.h>
+#define Sys_LoadLibrary(f) dlopen(f,RTLD_NOW)
+#define Sys_UnloadLibrary(h) dlclose(h)
+#define Sys_LoadFunction(h,fn) dlsym(h,fn)
+#define Sys_LibraryError() dlerror()
+#endif
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./sys/sys_local.h /home/pelya/src/endless_space/kwaak3/ioquake3/code/sys/sys_local.h
--- ./sys/sys_local.h	2012-05-25 15:53:12.969178827 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/sys/sys_local.h	2012-05-25 14:17:14.617231547 +0300
@@ -33,6 +33,7 @@
 void IN_Frame( void );
 void IN_Shutdown( void );
 void IN_Restart( void );
+qboolean IN_MotionPressed( void );
 
 // Console
 void CON_Shutdown( void );
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./sys/sys_main.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/sys/sys_main.c
--- ./sys/sys_main.c	2012-05-25 15:53:12.969178827 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/sys/sys_main.c	2012-05-25 14:17:14.617231547 +0300
@@ -31,6 +31,7 @@
 #include <ctype.h>
 #include <errno.h>
 
+#if !defined(NOKIA)
 #ifndef DEDICATED
 #ifdef USE_LOCAL_HEADERS
 #	include "SDL.h"
@@ -40,6 +41,7 @@
 #	include <SDL_cpuinfo.h>
 #endif
 #endif
+#endif
 
 #include "sys_local.h"
 #include "sys_loadlib.h"
@@ -47,6 +49,8 @@
 #include "../qcommon/q_shared.h"
 #include "../qcommon/qcommon.h"
 
+#include <android/log.h>
+
 static char binaryPath[ MAX_OSPATH ] = { 0 };
 static char installPath[ MAX_OSPATH ] = { 0 };
 
@@ -138,9 +142,11 @@
 {
 	CON_Shutdown( );
 
+#if !defined(NOKIA)
 #ifndef DEDICATED
 	SDL_Quit( );
 #endif
+#endif
 
 #ifdef NDEBUG
 	exit( ex );
@@ -171,6 +177,7 @@
 {
 	cpuFeatures_t features = 0;
 
+#if !defined(NOKIA)
 #ifndef DEDICATED
 	if( SDL_HasRDTSC( ) )    features |= CF_RDTSC;
 	if( SDL_HasMMX( ) )      features |= CF_MMX;
@@ -181,6 +188,7 @@
 	if( SDL_HasSSE2( ) )     features |= CF_SSE2;
 	if( SDL_HasAltiVec( ) )  features |= CF_ALTIVEC;
 #endif
+#endif
 
 	return features;
 }
@@ -400,7 +408,10 @@
 
 	assert( name );
 
-	Q_snprintf (fname, sizeof(fname), "%s" ARCH_STRING DLL_EXT, name);
+	/* On android libraries need to be prefixed with 'lib' else the loader
+	 * refuses to load them.
+	 */
+	Q_snprintf (fname, sizeof(fname), "lib%s" ARCH_STRING DLL_EXT, name);
 
 	// TODO: use fs_searchpaths from files.c
 	pwdpath = Sys_Cwd();
@@ -408,7 +419,11 @@
 	homepath = Cvar_VariableString( "fs_homepath" );
 	gamedir = Cvar_VariableString( "fs_game" );
 
-	libHandle = Sys_TryLibraryLoad(pwdpath, gamedir, fname, fqpath);
+	/* The libraries are shipped in the package directory and can't be loaded from
+	 * e.g. the sdcard because it seems to be mounted noexec or the loader just doesn't
+	 * allow it.
+	 */
+	libHandle = Sys_TryLibraryLoad(pwdpath, "/data/data/org.kwaak3/lib", fname, fqpath);
 
 	if(!libHandle && homepath)
 		libHandle = Sys_TryLibraryLoad(homepath, gamedir, fname, fqpath);
@@ -505,7 +520,9 @@
 {
 	int   i;
 	char  commandLine[ MAX_STRING_CHARS ] = { 0 };
+    __android_log_print(ANDROID_LOG_DEBUG, "Quake", "Inside Quake3 source!");
 
+#if !defined(NOKIA)
 #ifndef DEDICATED
 	// SDL version check
 
@@ -529,6 +546,7 @@
 		Sys_Exit( 1 );
 	}
 #endif
+#endif
 
 	Sys_PlatformInit( );
 
@@ -536,11 +554,11 @@
 	Sys_Milliseconds( );
 
 	Sys_ParseArgs( argc, argv );
-	Sys_SetBinaryPath( Sys_Dirname( argv[ 0 ] ) );
+//	Sys_SetBinaryPath( Sys_Dirname( argv[ 0 ] ) );
 	Sys_SetDefaultInstallPath( DEFAULT_BASEDIR );
 
 	// Concatenate the command line for passing to Com_Init
-	for( i = 1; i < argc; i++ )
+	for( i = 0; i < argc; i++ )
 	{
 		Q_strcat( commandLine, sizeof( commandLine ), argv[ i ] );
 		Q_strcat( commandLine, sizeof( commandLine ), " " );
@@ -556,19 +574,26 @@
 	signal( SIGSEGV, Sys_SigHandler );
 	signal( SIGTERM, Sys_SigHandler );
 
+#if 0
 	while( 1 )
 	{
+#if !defined(NOKIA)
 #ifndef DEDICATED
 		int appState = SDL_GetAppState( );
 
 		Cvar_SetValue( "com_unfocused",	!( appState & SDL_APPINPUTFOCUS ) );
 		Cvar_SetValue( "com_minimized", !( appState & SDL_APPACTIVE ) );
 #endif
+#endif
 
-		IN_Frame( );
-		Com_Frame( );
 	}
+#endif
 
 	return 0;
 }
 
+void nextFrame()
+{
+	IN_Frame( );
+	Com_Frame( );
+}
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./sys/sys_unix.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/sys/sys_unix.c
--- ./sys/sys_unix.c	2012-05-25 15:53:12.969178827 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/sys/sys_unix.c	2012-05-25 14:17:14.617231547 +0300
@@ -50,14 +50,10 @@
 
 	if( !*homePath )
 	{
-		if( ( p = getenv( "HOME" ) ) != NULL )
+		if( ( p = getenv( "GAME_PATH" ) ) != NULL )
 		{
 			Q_strncpyz( homePath, p, sizeof( homePath ) );
-#ifdef MACOS_X
-			Q_strcat( homePath, sizeof( homePath ), "/Library/Application Support/Quake3" );
-#else
-			Q_strcat( homePath, sizeof( homePath ), "/.q3a" );
-#endif
+
 			if( mkdir( homePath, 0777 ) )
 			{
 				if( errno != EEXIST )
@@ -68,7 +64,6 @@
 			}
 		}
 	}
-
 	return homePath;
 }
 
diff -x .svn -x '*.diff' --unidirectional-new-file -r -u ./ui/ui_main.c /home/pelya/src/endless_space/kwaak3/ioquake3/code/ui/ui_main.c
--- ./ui/ui_main.c	2012-05-25 15:53:12.781178830 +0300
+++ /home/pelya/src/endless_space/kwaak3/ioquake3/code/ui/ui_main.c	2012-05-25 14:17:14.317231551 +0300
@@ -5194,19 +5194,21 @@
 */
 void _UI_MouseEvent( int dx, int dy )
 {
+	//printf(__FILE__ "_UI_MouseEvent(%d,%d)\n", dx, dy);
 	// update mouse screen position
-	uiInfo.uiDC.cursorx += dx;
+	uiInfo.uiDC.cursorx = dx;
 	if (uiInfo.uiDC.cursorx < 0)
 		uiInfo.uiDC.cursorx = 0;
 	else if (uiInfo.uiDC.cursorx > SCREEN_WIDTH)
 		uiInfo.uiDC.cursorx = SCREEN_WIDTH;
 
-	uiInfo.uiDC.cursory += dy;
+	uiInfo.uiDC.cursory = dy;
 	if (uiInfo.uiDC.cursory < 0)
 		uiInfo.uiDC.cursory = 0;
 	else if (uiInfo.uiDC.cursory > SCREEN_HEIGHT)
 		uiInfo.uiDC.cursory = SCREEN_HEIGHT;
 
+__android_log_print(ANDROID_LOG_DEBUG, "Quake_NATIVE", "_UI_MouseEvent cursorxx=%d cursory=%d\n", uiInfo.uiDC.cursorx, uiInfo.uiDC.cursory);
   if (Menu_Count() > 0) {
     //menuDef_t *menu = Menu_GetFocused();
     //Menu_HandleMouseMove(menu, uiInfo.uiDC.cursorx, uiInfo.uiDC.cursory);
